/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x1000004a generated on 2023-04-12 07:25:52.518597
/// Generated using solver transform6d
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x1000004a);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62,x63,x64,x65,x66,x67,x68,x69,x70,x71,x72,x73,x74,x75,x76,x77,x78;
x0=IKcos(j[0]);
x1=IKsin(j[0]);
x2=IKsin(j[2]);
x3=IKcos(j[2]);
x4=IKsin(j[1]);
x5=IKcos(j[1]);
x6=IKcos(j[3]);
x7=IKsin(j[3]);
x8=IKcos(j[4]);
x9=IKsin(j[4]);
x10=IKcos(j[5]);
x11=IKsin(j[5]);
x12=IKcos(j[7]);
x13=IKsin(j[6]);
x14=IKsin(j[7]);
x15=IKcos(j[6]);
x16=((1.0)*x11);
x17=((1.0)*x9);
x18=((1.0)*x1);
x19=((1.0)*x10);
x20=((1.0)*x6);
x21=((1.0)*x3);
x22=(x4*x7);
x23=(x5*x6);
x24=(x0*x3);
x25=((-1.0)*x10);
x26=(x2*x5);
x27=(x0*x2);
x28=(x5*x7);
x29=((-1.0)*x0);
x30=((-1.0)*x11);
x31=((-1.0)*x6);
x32=((-1.0)*x7);
x33=((-1.0)*x1);
x34=((0.0325)*x22);
x35=((1.0)*x0*x28);
x36=(x18*x28);
x37=(x20*x3*x5);
x38=((0.0325)*x23*x3);
x39=(((x27*x4))+(((-1.0)*x18*x3)));
x40=(x27+(((-1.0)*x18*x3*x4)));
x41=(((x1*x2*x4))+x24);
x42=((((-1.0)*x22))+x37);
x43=((1.0)*x40);
x44=((((-1.0)*x18*x2))+(((-1.0)*x0*x21*x4)));
x45=(x39*x9);
x46=(x41*x9);
x47=(x40*x6);
x48=(((x21*x28))+((x20*x4)));
x49=((-1.0)*x48);
x50=(x39*x8);
x51=(x40*x7);
x52=(x41*x8);
x53=(x42*x9);
x54=(x44*x6);
x55=((-1.0)*x44);
x56=(x10*x49);
x57=(((x1*x23))+x51);
x58=(((x8*(((((-1.0)*x37))+x22))))+((x26*x9)));
x59=(x53+((x26*x8)));
x60=(((x0*x23))+((x44*x7)));
x61=(x10*x57);
x62=(x11*x58);
x63=(x15*x59);
x64=(x35+((x31*x44)));
x65=(x10*x60);
x66=(((x23*x29))+((x32*x44)));
x67=(x64*x9);
x68=(x30*((((x23*x33))+((x32*x40)))));
x69=(x46+((x8*(((((-1.0)*x36))+x47)))));
x70=(((x8*((((x28*x33))+x47))))+x46);
x71=(((x8*(((((-1.0)*x35))+x54))))+x45);
x72=(((x8*((((x28*x29))+x54))))+x45);
x73=(x15*((((x9*((x36+((x31*x40))))))+x52)));
x74=((((-1.0)*x16*x48))+(((-1.0)*x19*x58)));
x75=(((x25*x58))+((x30*x48)));
x76=(x15*((x50+x67)));
x77=(x13*x75);
x78=((((-1.0)*x19*x71))+(((-1.0)*x16*x66)));
eerot[0]=(((x12*((x65+((x11*x72))))))+((x14*((((x13*((((x25*x72))+((x30*x66))))))+x76)))));
eerot[1]=(((x14*((((x30*x71))+((x25*x60))))))+((x12*((x76+((x13*x78)))))));
eerot[2]=(((x13*(((((-1.0)*x50))+(((-1.0)*x67))))))+((x15*x78)));
eetrans[0]=((0.023)+(((0.3351)*(IKcos(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))+(((-0.1491)*(IKsin(j[0]))))+(((((((-0.0325)*(IKsin(j[0]))*(IKsin(j[2]))))+(((-0.0325)*(IKcos(j[0]))*(IKcos(j[2]))*(IKsin(j[1]))))))*(IKcos(j[3]))))+(((((((((((0.048)*(((((1.0)*(IKsin(j[0]))*(IKsin(j[2]))))+(((1.0)*(IKcos(j[0]))*(IKcos(j[2]))*(IKsin(j[1]))))))*(IKcos(j[3]))))+(((0.048)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[3]))))))*(IKsin(j[4]))))+(((((((0.048)*(IKcos(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))+(((-0.048)*(IKcos(j[2]))*(IKsin(j[0]))))))*(IKcos(j[4]))))))*(IKcos(j[6]))))+(((-0.0325)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[3]))))+(((-0.3351)*(IKcos(j[2]))*(IKsin(j[0]))))+(((((((((((-0.0375)*(((((-1.0)*(IKsin(j[0]))*(IKsin(j[2]))))+(((-1.0)*(IKcos(j[0]))*(IKcos(j[2]))*(IKsin(j[1]))))))*(IKsin(j[3]))))+(((-0.0375)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKcos(j[5]))))+(((((((-0.0375)*(((((-1.0)*(IKcos(j[2]))*(IKsin(j[0]))))+(((IKcos(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))))*(IKsin(j[4]))))+(((-0.0375)*(((((-1.0)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[3]))))+(((((((-1.0)*(IKsin(j[0]))*(IKsin(j[2]))))+(((-1.0)*(IKcos(j[0]))*(IKcos(j[2]))*(IKsin(j[1]))))))*(IKcos(j[3]))))))*(IKcos(j[4]))))))*(IKsin(j[5]))))))*(IKsin(j[7]))))+(((((((((((-0.048)*(((((1.0)*(IKsin(j[0]))*(IKsin(j[2]))))+(((1.0)*(IKcos(j[0]))*(IKcos(j[2]))*(IKsin(j[1]))))))*(IKsin(j[3]))))+(((0.048)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKsin(j[5]))))+(((((((-0.048)*(((((-1.0)*(IKcos(j[2]))*(IKsin(j[0]))))+(((IKcos(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))))*(IKsin(j[4]))))+(((-0.048)*(((((-1.0)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[3]))))+(((((((-1.0)*(IKsin(j[0]))*(IKsin(j[2]))))+(((-1.0)*(IKcos(j[0]))*(IKcos(j[2]))*(IKsin(j[1]))))))*(IKcos(j[3]))))))*(IKcos(j[4]))))))*(IKcos(j[5]))))))*(IKsin(j[6]))))+(((((((0.2688)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[3]))))+(((((((0.2688)*(IKsin(j[0]))*(IKsin(j[2]))))+(((0.2688)*(IKcos(j[0]))*(IKcos(j[2]))*(IKsin(j[1]))))))*(IKcos(j[3]))))))*(IKsin(j[4]))))+(((((((((((0.0375)*(((((-1.0)*(((((-1.0)*(IKcos(j[2]))*(IKsin(j[0]))))+(((IKcos(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))))*(IKsin(j[4]))))+(((-1.0)*(((((-1.0)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[3]))))+(((((((-1.0)*(IKsin(j[0]))*(IKsin(j[2]))))+(((-1.0)*(IKcos(j[0]))*(IKcos(j[2]))*(IKsin(j[1]))))))*(IKcos(j[3]))))))*(IKcos(j[4]))))))*(IKcos(j[5]))))+(((0.0375)*(((((-1.0)*(((((1.0)*(IKsin(j[0]))*(IKsin(j[2]))))+(((1.0)*(IKcos(j[0]))*(IKcos(j[2]))*(IKsin(j[1]))))))*(IKsin(j[3]))))+(((1.0)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKsin(j[5]))))))*(IKsin(j[6]))))+(((((((0.0375)*(((((1.0)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[3]))))+(((((((1.0)*(IKsin(j[0]))*(IKsin(j[2]))))+(((1.0)*(IKcos(j[0]))*(IKcos(j[2]))*(IKsin(j[1]))))))*(IKcos(j[3]))))))*(IKsin(j[4]))))+(((0.0375)*(((((-1.0)*(IKcos(j[2]))*(IKsin(j[0]))))+(((IKcos(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))))*(IKcos(j[4]))))))*(IKcos(j[6]))))))*(IKcos(j[7]))))+(((((((((((0.0325)*(IKcos(j[0]))*(IKcos(j[2]))*(IKsin(j[1]))))+(((0.0325)*(IKsin(j[0]))*(IKsin(j[2]))))))*(IKcos(j[3]))))+(((0.0325)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[3]))))))*(IKcos(j[4]))))+(((((((-0.2688)*(IKcos(j[2]))*(IKsin(j[0]))))+(((0.2688)*(IKcos(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))))*(IKcos(j[4]))))+(((((((-0.0325)*(IKcos(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))+(((0.0325)*(IKcos(j[2]))*(IKsin(j[0]))))))*(IKsin(j[4])))));
eerot[3]=(((x14*((x73+((x13*((((x25*x69))+x68))))))))+((x12*((((x11*x69))+x61)))));
eerot[4]=(((x12*(((((-1.0)*x13*((((x16*(((((-1.0)*x18*x23))+(((-1.0)*x43*x7))))))+((x19*x70))))))+x73))))+((x14*((((x30*x70))+((x25*x57)))))));
eerot[5]=((((-1.0)*x13*((((x17*(((((-1.0)*x20*x40))+x36))))+(((1.0)*x52))))))+((x15*((x68+((x25*x70)))))));
eetrans[1]=((0.154)+(((0.3351)*(IKcos(j[0]))*(IKcos(j[2]))))+(((((((-0.0325)*(IKcos(j[2]))*(IKsin(j[0]))*(IKsin(j[1]))))+(((0.0325)*(IKcos(j[0]))*(IKsin(j[2]))))))*(IKcos(j[3]))))+(((((((((((0.2688)*(IKcos(j[2]))*(IKsin(j[0]))*(IKsin(j[1]))))+(((-0.2688)*(IKcos(j[0]))*(IKsin(j[2]))))))*(IKcos(j[3]))))+(((0.2688)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[3]))))))*(IKsin(j[4]))))+(((0.1491)*(IKcos(j[0]))))+(((((((((((0.0375)*(((((-1.0)*(((((1.0)*(IKcos(j[2]))*(IKsin(j[0]))*(IKsin(j[1]))))+(((-1.0)*(IKcos(j[0]))*(IKsin(j[2]))))))*(IKsin(j[3]))))+(((1.0)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))))*(IKsin(j[5]))))+(((0.0375)*(((((-1.0)*(((((((((IKcos(j[0]))*(IKsin(j[2]))))+(((-1.0)*(IKcos(j[2]))*(IKsin(j[0]))*(IKsin(j[1]))))))*(IKcos(j[3]))))+(((-1.0)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[3]))))))*(IKcos(j[4]))))+(((-1.0)*(((((IKcos(j[0]))*(IKcos(j[2]))))+(((IKsin(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))))*(IKsin(j[4]))))))*(IKcos(j[5]))))))*(IKsin(j[6]))))+(((((((0.0375)*(((((((((1.0)*(IKcos(j[2]))*(IKsin(j[0]))*(IKsin(j[1]))))+(((-1.0)*(IKcos(j[0]))*(IKsin(j[2]))))))*(IKcos(j[3]))))+(((1.0)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[3]))))))*(IKsin(j[4]))))+(((0.0375)*(((((IKcos(j[0]))*(IKcos(j[2]))))+(((IKsin(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))))*(IKcos(j[4]))))))*(IKcos(j[6]))))))*(IKcos(j[7]))))+(((((((0.2688)*(IKsin(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))+(((0.2688)*(IKcos(j[0]))*(IKcos(j[2]))))))*(IKcos(j[4]))))+(((((((((((-0.0375)*(((((IKcos(j[0]))*(IKcos(j[2]))))+(((IKsin(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))))*(IKsin(j[4]))))+(((-0.0375)*(((((((((IKcos(j[0]))*(IKsin(j[2]))))+(((-1.0)*(IKcos(j[2]))*(IKsin(j[0]))*(IKsin(j[1]))))))*(IKcos(j[3]))))+(((-1.0)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[3]))))))*(IKcos(j[4]))))))*(IKsin(j[5]))))+(((((((-0.0375)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((-0.0375)*(((((IKcos(j[0]))*(IKsin(j[2]))))+(((-1.0)*(IKcos(j[2]))*(IKsin(j[0]))*(IKsin(j[1]))))))*(IKsin(j[3]))))))*(IKcos(j[5]))))))*(IKsin(j[7]))))+(((((((((((-0.048)*(((((((((IKcos(j[0]))*(IKsin(j[2]))))+(((-1.0)*(IKcos(j[2]))*(IKsin(j[0]))*(IKsin(j[1]))))))*(IKcos(j[3]))))+(((-1.0)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[3]))))))*(IKcos(j[4]))))+(((-0.048)*(((((IKcos(j[0]))*(IKcos(j[2]))))+(((IKsin(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))))*(IKsin(j[4]))))))*(IKcos(j[5]))))+(((((((0.048)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((-0.048)*(((((1.0)*(IKcos(j[2]))*(IKsin(j[0]))*(IKsin(j[1]))))+(((-1.0)*(IKcos(j[0]))*(IKsin(j[2]))))))*(IKsin(j[3]))))))*(IKsin(j[5]))))))*(IKsin(j[6]))))+(((-0.0325)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[3]))))+(((((((((((0.048)*(((((1.0)*(IKcos(j[2]))*(IKsin(j[0]))*(IKsin(j[1]))))+(((-1.0)*(IKcos(j[0]))*(IKsin(j[2]))))))*(IKcos(j[3]))))+(((0.048)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[3]))))))*(IKsin(j[4]))))+(((((((0.048)*(IKsin(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))+(((0.048)*(IKcos(j[0]))*(IKcos(j[2]))))))*(IKcos(j[4]))))))*(IKcos(j[6]))))+(((0.3351)*(IKsin(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))+(((((((0.0325)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[3]))))+(((((((0.0325)*(IKcos(j[2]))*(IKsin(j[0]))*(IKsin(j[1]))))+(((-0.0325)*(IKcos(j[0]))*(IKsin(j[2]))))))*(IKcos(j[3]))))))*(IKcos(j[4]))))+(((((((-0.0325)*(IKsin(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))+(((-0.0325)*(IKcos(j[0]))*(IKcos(j[2]))))))*(IKsin(j[4])))));
eerot[6]=(((x12*((x56+x62))))+((x14*((x77+x63)))));
eerot[7]=(((x14*((((x30*x58))+((x25*x49))))))+((x12*((x63+((x13*x74)))))));
eerot[8]=(((x13*(((((-1.0)*x17*x42))+(((-1.0)*x26*x8))))))+((x15*x74)));
IkReal x79=(x26*x8);
eetrans[2]=((0.2925)+((x12*(((((0.0375)*x77))+(((0.0375)*x63))))))+(((-1.0)*x38))+((x15*(((((0.048)*x79))+(((0.048)*x53))))))+(((0.3351)*x26))+((x13*(((((-0.048)*x11*x48))+(((-0.048)*x10*x58))))))+(((0.2688)*x79))+x34+((x9*(((((0.2688)*x23*x3))+(((-0.2688)*x22))))))+((x8*(((((-1.0)*x34))+x38))))+(((-0.0325)*x26*x9))+((x14*(((((-0.0375)*x62))+(((-0.0375)*x56)))))));
}

IKFAST_API int GetNumFreeParameters() { return 2; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {6, 7}; return freeparams; }
IKFAST_API int GetNumJoints() { return 8; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,j6,cj6,sj6,htj6,j7,cj7,sj7,htj7,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5,_ij6[2], _nj6,_ij7[2], _nj7;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1;  _ij6[0] = -1; _ij6[1] = -1; _nj6 = 0;  _ij7[0] = -1; _ij7[1] = -1; _nj7 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j6=pfree[0]; cj6=cos(pfree[0]); sj6=sin(pfree[0]), htj6=tan(pfree[0]*0.5);
j7=pfree[1]; cj7=cos(pfree[1]); sj7=sin(pfree[1]), htj7=tan(pfree[1]*0.5);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=r00;
new_r01=r01;
new_r02=r02;
new_px=((-0.023)+px+(((-0.0375)*r01)));
new_r10=r10;
new_r11=r11;
new_r12=r12;
new_py=((-0.154)+py+(((-0.0375)*r11)));
new_r20=r20;
new_r21=r21;
new_r22=r22;
new_pz=((-0.2925)+(((-0.0375)*r21))+pz);
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x80=((1.0)*px);
IkReal x81=((1.0)*pz);
IkReal x82=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x82))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x81)));
rxp0_2=((((-1.0)*r10*x80))+((py*r00)));
rxp1_0=((((-1.0)*r21*x82))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x81)));
rxp1_2=((((-1.0)*r11*x80))+((py*r01)));
rxp2_0=((((-1.0)*r22*x82))+((pz*r12)));
rxp2_1=((((-1.0)*r02*x81))+((px*r22)));
rxp2_2=((((-1.0)*r12*x80))+((py*r02)));
IkReal op[8+1], zeror[8];
int numroots;
IkReal x83=(npz*sj6);
IkReal x84=((0.048)*cj6);
IkReal x85=((0.2982)*py);
IkReal x86=(cj6*cj7);
IkReal x87=(r10*sj7);
IkReal x88=(npx*sj7);
IkReal x89=(r00*sj7);
IkReal x90=((0.0143136)*x87);
IkReal x91=((0.0143136)*cj7*r11);
IkReal x92=((0.096)*cj7*npy);
IkReal x93=((0.096)*x88);
IkReal x94=((0.1491)*r12*sj6);
IkReal x95=(pp+x85);
IkReal x96=((0.1491)*r11*x86);
IkReal x97=((0.1491)*cj6*x87);
IkReal x98=((1.0)*cj6*x88);
IkReal x99=((1.0)*npy*x86);
IkReal x100=((0.6039)+x83+x84);
IkReal x101=((-0.0663)+x83+x84);
IkReal x102=(x93+x92);
IkReal x103=((((-0.0286272)*cj7*r01))+(((0.5964)*px))+(((-0.0286272)*x89)));
IkReal x104=(pp+x91+x90);
IkReal x105=(x102+x85);
IkReal x106=(x97+x96);
IkReal x107=(x99+x98);
IkReal x108=((((-0.2982)*cj6*x89))+(((-0.2982)*r01*x86))+(((0.2982)*r02*sj6)));
IkReal x109=(x107+x94);
IkReal x110=(x102+x91+x90);
IkReal x111=((-0.3401604)+(((-1.0)*x105))+x104);
IkReal x112=((0.01591412)+(((-1.0)*x105))+x104);
IkReal x113=((-0.3401604)+(((-1.0)*x110))+x95);
IkReal x114=((0.01591412)+(((-1.0)*x110))+x95);
IkReal x115=(x106+x107);
IkReal x116=((((-1.0)*x109))+x106+x100);
IkReal x117=((((-1.0)*x109))+x106+x101);
IkReal x118=((((-1.0)*x115))+x100+x94);
IkReal x119=((((-1.0)*x115))+x101+x94);
IkReal gconst0=x111;
IkReal gconst1=x112;
IkReal gconst2=x116;
IkReal gconst3=x117;
IkReal gconst4=x111;
IkReal gconst5=x112;
IkReal gconst6=x116;
IkReal gconst7=x117;
IkReal gconst8=x103;
IkReal gconst9=x103;
IkReal gconst10=x108;
IkReal gconst11=x108;
IkReal gconst12=x103;
IkReal gconst13=x103;
IkReal gconst14=x108;
IkReal gconst15=x108;
IkReal gconst16=x113;
IkReal gconst17=x114;
IkReal gconst18=x118;
IkReal gconst19=x119;
IkReal gconst20=x113;
IkReal gconst21=x114;
IkReal gconst22=x118;
IkReal gconst23=x119;
IkReal x120=(gconst1*gconst4);
IkReal x121=(gconst11*gconst6);
IkReal x122=(gconst0*gconst5);
IkReal x123=(gconst18*gconst20);
IkReal x124=(gconst17*gconst18);
IkReal x125=((1.0)*gconst21);
IkReal x126=((1.0)*gconst6);
IkReal x127=(gconst1*gconst10);
IkReal x128=(gconst15*gconst9);
IkReal x129=(gconst11*gconst14);
IkReal x130=((0.004225)*gconst12);
IkReal x131=(gconst2*gconst5);
IkReal x132=(gconst11*gconst16);
IkReal x133=(gconst13*gconst22);
IkReal x134=(gconst0*gconst3);
IkReal x135=(gconst21*gconst6);
IkReal x136=(gconst19*gconst6);
IkReal x137=(gconst0*gconst19);
IkReal x138=(gconst12*gconst23);
IkReal x139=(gconst1*gconst6);
IkReal x140=((1.0)*gconst23);
IkReal x141=(gconst18*gconst9);
IkReal x142=(gconst13*gconst14);
IkReal x143=((0.006163349049)*gconst3);
IkReal x144=(gconst2*gconst4);
IkReal x145=((0.005102955)*gconst20);
IkReal x146=(gconst19*gconst8);
IkReal x147=(gconst16*gconst19);
IkReal x148=(gconst21*gconst22);
IkReal x149=(gconst17*gconst22);
IkReal x150=(gconst17*gconst7);
IkReal x151=(gconst1*gconst18);
IkReal x152=(gconst0*gconst11);
IkReal x153=((0.005102955)*gconst12);
IkReal x154=((0.005102955)*gconst4);
IkReal x155=(gconst14*gconst21);
IkReal x156=(gconst12*gconst7);
IkReal x157=((0.005102955)*gconst9);
IkReal x158=(gconst12*gconst15);
IkReal x159=(gconst17*gconst20);
IkReal x160=(gconst10*gconst15);
IkReal x161=(gconst16*gconst3);
IkReal x162=(gconst20*gconst7);
IkReal x163=(gconst7*gconst9);
IkReal x164=(gconst3*gconst8);
IkReal x165=(gconst19*gconst22);
IkReal x166=((0.004225)*gconst20);
IkReal x167=(gconst1*gconst2);
IkReal x168=(gconst1*gconst22);
IkReal x169=(gconst10*gconst9);
IkReal x170=(gconst22*gconst5);
IkReal x171=(gconst2*gconst9);
IkReal x172=(gconst10*gconst17);
IkReal x173=((0.004225)*gconst4);
IkReal x174=(gconst3*gconst6);
IkReal x175=(gconst2*gconst23);
IkReal x176=(gconst5*gconst6);
IkReal x177=((1.0)*gconst14);
IkReal x178=(gconst13*gconst6);
IkReal x179=(gconst11*gconst8);
IkReal x180=((0.005102955)*gconst14);
IkReal x181=(gconst19*x154);
IkReal x182=(gconst17*x173);
IkReal x183=((0.005102955)*x168);
IkReal x184=((0.005102955)*gconst17*gconst6);
IkReal x185=(gconst9*x130);
IkReal x186=(gconst11*x153);
IkReal x187=(gconst14*x157);
IkReal x188=(gconst22*x143);
IkReal x189=((0.006163349049)*x136);
IkReal x190=((0.006163349049)*x129);
IkReal x191=(gconst3*x145);
IkReal x192=(gconst1*x166);
IkReal x193=((1.0)*gconst4*gconst7);
IkReal x194=((1.0)*gconst15*gconst20);
IkReal x195=((1.0)*gconst15*gconst4);
IkReal x196=(x192+x191+x190+x184+x185+x186+x187+x181+x182+x183+x188+x189);
op[0]=(((gconst17*gconst23*x123))+((x147*x148))+(((-0.004225)*x159))+(((-0.006163349049)*x165))+(((-0.005102955)*x149))+(((-1.0)*gconst22*x124*x125))+(((-1.0)*gconst20*x140*x147))+(((-1.0)*gconst19*x145)));
op[1]=((((-1.0)*gconst14*x124*x125))+(((-0.006163349049)*gconst14*gconst19))+((gconst10*gconst23*x159))+(((-1.0)*x124*x133))+(((-1.0)*gconst22*x125*x141))+(((-1.0)*gconst22*x157))+(((-1.0)*gconst10*x125*x149))+(((-1.0)*gconst9*x166))+((gconst23*gconst9*x123))+((x124*x138))+(((-1.0)*gconst17*x180))+(((-1.0)*x147*x194))+(((-1.0)*gconst17*x130))+((gconst15*gconst17*x123))+((x146*x148))+((x147*x155))+(((-1.0)*gconst20*x140*x146))+((x132*x148))+(((-1.0)*gconst19*x153))+(((-1.0)*gconst20*x132*x140))+((x133*x147))+(((-1.0)*gconst11*x145))+(((-1.0)*x138*x147))+(((-0.006163349049)*gconst11*gconst22)));
op[2]=(((x142*x147))+((x123*x150))+(((-1.0)*gconst20*x140*x179))+((gconst16*gconst21*x129))+((gconst20*gconst23*x169))+(((-1.0)*gconst22*x125*x169))+(((-0.012326698098)*x165))+(((-0.01020591)*gconst19*gconst20))+(((-1.0)*gconst22*x125*x151))+(((-1.0)*x133*x141))+((x137*x148))+(((-1.0)*x133*x172))+(((-1.0)*x196))+((x138*x172))+(((-1.0)*x124*x142))+((x138*x141))+(((-1.0)*gconst2*x125*x149))+(((-1.0)*x146*x194))+((x135*x147))+(((-1.0)*gconst20*x137*x140))+(((-1.0)*x132*x194))+((x148*x161))+(((-0.00845)*x159))+((x123*x128))+((x148*x179))+((x147*x170))+(((-1.0)*x132*x138))+((x146*x155))+(((-1.0)*x124*x170))+(((-1.0)*gconst6*x124*x125))+((gconst1*gconst23*x123))+(((-1.0)*x147*x162))+((x132*x133))+(((-1.0)*gconst4*x140*x147))+(((-1.0)*x147*x158))+((x159*x175))+(((-0.01020591)*x149))+(((-1.0)*gconst14*x125*x141))+((x159*x160))+((x133*x146))+((gconst23*gconst4*x124))+(((-1.0)*gconst20*x140*x161))+((x124*x158))+(((-1.0)*gconst14*x125*x172))+(((-1.0)*x138*x146)));
op[3]=(((gconst11*gconst13*gconst22*gconst8))+(((-1.0)*gconst13*gconst17*gconst18*gconst6))+(((-0.004225)*gconst1*gconst12))+((gconst10*gconst17*gconst20*gconst7))+(((-0.01020591)*gconst11*gconst20))+(((-1.0)*gconst1*gconst10*gconst21*gconst22))+((gconst1*gconst12*gconst18*gconst23))+(((-0.005102955)*gconst6*gconst9))+(((-0.005102955)*gconst1*gconst14))+(((-1.0)*gconst10*gconst13*gconst14*gconst17))+((gconst0*gconst11*gconst21*gconst22))+((gconst12*gconst17*gconst18*gconst7))+((gconst14*gconst16*gconst21*gconst3))+(((-1.0)*gconst12*gconst16*gconst19*gconst7))+((gconst10*gconst15*gconst20*gconst9))+((gconst10*gconst12*gconst15*gconst17))+(((-0.012326698098)*gconst14*gconst19))+((gconst12*gconst17*gconst2*gconst23))+(((-0.00845)*gconst20*gconst9))+(((-1.0)*gconst15*gconst16*gconst19*gconst4))+((gconst13*gconst16*gconst22*gconst3))+((gconst13*gconst14*gconst19*gconst8))+((gconst15*gconst17*gconst18*gconst4))+(((-1.0)*gconst0*gconst12*gconst19*gconst23))+((gconst0*gconst13*gconst19*gconst22))+((gconst19*gconst21*gconst6*gconst8))+(((-0.005102955)*gconst12*gconst3))+(((-1.0)*gconst11*gconst12*gconst23*gconst8))+((gconst18*gconst23*gconst4*gconst9))+(((-1.0)*gconst13*gconst14*gconst18*gconst9))+((gconst10*gconst12*gconst23*gconst9))+((gconst1*gconst15*gconst18*gconst20))+(((-1.0)*gconst1*gconst13*gconst18*gconst22))+((gconst21*gconst22*gconst3*gconst8))+((gconst18*gconst20*gconst7*gconst9))+(((-0.005102955)*gconst11*gconst4))+(((-1.0)*gconst20*gconst23*gconst3*gconst8))+(((-1.0)*gconst0*gconst15*gconst19*gconst20))+(((-1.0)*gconst19*gconst20*gconst7*gconst8))+(((-1.0)*gconst11*gconst15*gconst20*gconst8))+(((-0.00845)*gconst12*gconst17))+((gconst13*gconst16*gconst19*gconst6))+(((-1.0)*gconst19*gconst23*gconst4*gconst8))+(((-0.006163349049)*gconst14*gconst3))+(((-1.0)*gconst12*gconst16*gconst23*gconst3))+((gconst12*gconst15*gconst18*gconst9))+(((-0.006163349049)*gconst11*gconst6))+(((-1.0)*gconst18*gconst22*gconst5*gconst9))+((gconst10*gconst17*gconst23*gconst4))+((gconst15*gconst17*gconst2*gconst20))+(((-1.0)*gconst11*gconst16*gconst20*gconst7))+(((-1.0)*gconst11*gconst16*gconst23*gconst4))+(((-1.0)*gconst11*gconst12*gconst15*gconst16))+(((-1.0)*gconst10*gconst14*gconst21*gconst9))+(((-1.0)*gconst14*gconst17*gconst2*gconst21))+(((-1.0)*gconst18*gconst21*gconst6*gconst9))+(((-1.0)*gconst14*gconst17*gconst18*gconst5))+(((-0.01020591)*gconst22*gconst9))+(((-0.01020591)*gconst14*gconst17))+(((-0.012326698098)*gconst11*gconst22))+((gconst0*gconst14*gconst19*gconst21))+(((-1.0)*gconst1*gconst14*gconst18*gconst21))+(((-1.0)*gconst10*gconst17*gconst21*gconst6))+((gconst11*gconst16*gconst22*gconst5))+(((-1.0)*gconst10*gconst17*gconst22*gconst5))+(((-0.01020591)*gconst12*gconst19))+((gconst11*gconst16*gconst21*gconst6))+((gconst11*gconst13*gconst14*gconst16))+(((-1.0)*gconst13*gconst17*gconst2*gconst22))+((gconst1*gconst10*gconst20*gconst23))+(((-1.0)*gconst2*gconst21*gconst22*gconst9))+((gconst11*gconst14*gconst21*gconst8))+((gconst2*gconst20*gconst23*gconst9))+((gconst14*gconst16*gconst19*gconst5))+((gconst19*gconst22*gconst5*gconst8))+(((-1.0)*gconst10*gconst13*gconst22*gconst9))+(((-0.004225)*gconst4*gconst9))+(((-1.0)*gconst0*gconst11*gconst20*gconst23))+(((-1.0)*gconst12*gconst15*gconst19*gconst8))+(((-1.0)*gconst15*gconst16*gconst20*gconst3)));
op[4]=((((-1.0)*gconst0*gconst19*gconst23*gconst4))+(((-1.0)*gconst0*gconst11*gconst12*gconst23))+(((-0.00845)*gconst1*gconst20))+(((-1.0)*gconst17*gconst2*gconst21*gconst6))+(((-1.0)*gconst16*gconst19*gconst4*gconst7))+(((-0.01020591)*gconst19*gconst4))+((gconst14*gconst19*gconst5*gconst8))+(((-0.01020591)*gconst11*gconst12))+(((-0.006163349049)*gconst3*gconst6))+(((-1.0)*gconst13*gconst14*gconst17*gconst2))+(((-1.0)*gconst10*gconst13*gconst14*gconst9))+((gconst13*gconst14*gconst16*gconst3))+(((-1.0)*gconst14*gconst18*gconst5*gconst9))+((gconst1*gconst18*gconst23*gconst4))+(((-1.0)*gconst17*gconst2*gconst22*gconst5))+(((-1.0)*gconst16*gconst20*gconst3*gconst7))+(((-1.0)*gconst11*gconst20*gconst7*gconst8))+((gconst13*gconst22*gconst3*gconst8))+((gconst10*gconst12*gconst17*gconst7))+((gconst1*gconst12*gconst15*gconst18))+(((-0.005102955)*gconst3*gconst4))+((gconst10*gconst12*gconst15*gconst9))+(((-1.0)*gconst1*gconst10*gconst13*gconst22))+(((-0.01020591)*gconst17*gconst6))+(((-1.0)*gconst1*gconst10*gconst14*gconst21))+((gconst17*gconst2*gconst20*gconst7))+((gconst11*gconst22*gconst5*gconst8))+((gconst16*gconst19*gconst5*gconst6))+(((-0.005102955)*gconst1*gconst6))+((gconst11*gconst14*gconst16*gconst5))+(((-1.0)*gconst11*gconst23*gconst4*gconst8))+((gconst16*gconst22*gconst3*gconst5))+((gconst10*gconst15*gconst17*gconst4))+((gconst17*gconst2*gconst23*gconst4))+((gconst15*gconst2*gconst20*gconst9))+(((-1.0)*gconst10*gconst21*gconst6*gconst9))+(((-1.0)*gconst11*gconst12*gconst15*gconst8))+((gconst1*gconst2*gconst20*gconst23))+((gconst1*gconst10*gconst12*gconst23))+((gconst1*gconst18*gconst20*gconst7))+(((-0.01020591)*gconst1*gconst22))+((gconst0*gconst13*gconst14*gconst19))+(((-0.004225)*gconst17*gconst20))+(((-1.0)*gconst13*gconst18*gconst6*gconst9))+((gconst11*gconst13*gconst14*gconst8))+((gconst0*gconst19*gconst21*gconst6))+((gconst10*gconst23*gconst4*gconst9))+((gconst0*gconst11*gconst14*gconst21))+(((-1.0)*gconst1*gconst13*gconst14*gconst18))+(((-1.0)*gconst17*gconst18*gconst5*gconst6))+(((-0.006163349049)*gconst19*gconst22))+(((-0.00845)*gconst17*gconst4))+((gconst0*gconst11*gconst13*gconst22))+(((-1.0)*gconst13*gconst2*gconst22*gconst9))+((gconst17*gconst18*gconst4*gconst7))+(((-0.012326698098)*gconst11*gconst14))+((gconst11*gconst13*gconst16*gconst6))+((gconst0*gconst19*gconst22*gconst5))+((gconst0*gconst21*gconst22*gconst3))+(((-1.0)*gconst12*gconst15*gconst16*gconst3))+(((-1.0)*gconst14*gconst2*gconst21*gconst9))+((gconst12*gconst15*gconst17*gconst2))+(((-1.0)*gconst0*gconst20*gconst23*gconst3))+(((-1.0)*gconst11*gconst15*gconst16*gconst4))+((gconst12*gconst2*gconst23*gconst9))+(((-0.005102955)*gconst19*gconst20))+((gconst11*gconst21*gconst6*gconst8))+((gconst14*gconst21*gconst3*gconst8))+(((-0.01020591)*gconst20*gconst3))+(((-1.0)*gconst15*gconst20*gconst3*gconst8))+(((-1.0)*gconst0*gconst11*gconst15*gconst20))+(((-0.004225)*gconst1*gconst4))+(((-1.0)*gconst12*gconst19*gconst7*gconst8))+(((-1.0)*gconst10*gconst14*gconst17*gconst5))+(((-1.0)*gconst1*gconst18*gconst22*gconst5))+(((-1.0)*gconst10*gconst22*gconst5*gconst9))+((gconst12*gconst18*gconst7*gconst9))+(((-0.012326698098)*gconst22*gconst3))+(((-0.005102955)*gconst17*gconst22))+(((-1.0)*gconst12*gconst23*gconst3*gconst8))+(((-1.0)*gconst0*gconst19*gconst20*gconst7))+((gconst15*gconst18*gconst4*gconst9))+(((-1.0)*gconst10*gconst13*gconst17*gconst6))+(((-0.00845)*gconst12*gconst9))+(((-1.0)*gconst1*gconst2*gconst21*gconst22))+((gconst10*gconst20*gconst7*gconst9))+(((-1.0)*gconst11*gconst12*gconst16*gconst7))+(((-1.0)*gconst1*gconst18*gconst21*gconst6))+((gconst1*gconst10*gconst15*gconst20))+((gconst13*gconst19*gconst6*gconst8))+(((-0.01020591)*gconst14*gconst9))+(((-1.0)*gconst15*gconst19*gconst4*gconst8))+(((-1.0)*gconst16*gconst23*gconst3*gconst4))+(((-1.0)*gconst0*gconst12*gconst15*gconst19))+((gconst16*gconst21*gconst3*gconst6))+(((-0.012326698098)*gconst19*gconst6)));
op[5]=(((gconst1*gconst12*gconst18*gconst7))+(((-1.0)*gconst2*gconst21*gconst6*gconst9))+((gconst0*gconst14*gconst19*gconst5))+(((-0.00845)*gconst1*gconst12))+(((-0.01020591)*gconst12*gconst3))+(((-0.005102955)*gconst14*gconst17))+((gconst15*gconst17*gconst2*gconst4))+((gconst1*gconst12*gconst2*gconst23))+(((-0.005102955)*gconst12*gconst19))+(((-1.0)*gconst11*gconst16*gconst4*gconst7))+(((-0.004225)*gconst12*gconst17))+(((-1.0)*gconst15*gconst16*gconst3*gconst4))+(((-1.0)*gconst1*gconst13*gconst18*gconst6))+(((-0.006163349049)*gconst14*gconst19))+(((-1.0)*gconst1*gconst10*gconst13*gconst14))+(((-1.0)*gconst14*gconst17*gconst2*gconst5))+(((-1.0)*gconst19*gconst4*gconst7*gconst8))+(((-1.0)*gconst1*gconst10*gconst21*gconst6))+((gconst2*gconst23*gconst4*gconst9))+((gconst0*gconst13*gconst19*gconst6))+(((-0.01020591)*gconst6*gconst9))+(((-0.005102955)*gconst11*gconst20))+(((-1.0)*gconst10*gconst13*gconst6*gconst9))+(((-1.0)*gconst1*gconst14*gconst2*gconst21))+((gconst19*gconst5*gconst6*gconst8))+(((-1.0)*gconst2*gconst22*gconst5*gconst9))+((gconst1*gconst15*gconst2*gconst20))+((gconst1*gconst10*gconst23*gconst4))+(((-1.0)*gconst0*gconst12*gconst23*gconst3))+(((-1.0)*gconst0*gconst12*gconst19*gconst7))+(((-1.0)*gconst0*gconst15*gconst20*gconst3))+((gconst11*gconst16*gconst5*gconst6))+((gconst10*gconst17*gconst4*gconst7))+(((-0.012326698098)*gconst14*gconst3))+(((-0.01020591)*gconst1*gconst14))+(((-0.012326698098)*gconst11*gconst6))+(((-0.004225)*gconst20*gconst9))+(((-1.0)*gconst1*gconst13*gconst2*gconst22))+((gconst1*gconst10*gconst12*gconst15))+((gconst0*gconst14*gconst21*gconst3))+(((-1.0)*gconst23*gconst3*gconst4*gconst8))+((gconst0*gconst11*gconst13*gconst14))+(((-1.0)*gconst10*gconst17*gconst5*gconst6))+((gconst0*gconst11*gconst22*gconst5))+(((-0.01020591)*gconst11*gconst4))+((gconst1*gconst15*gconst18*gconst4))+((gconst13*gconst14*gconst3*gconst8))+((gconst12*gconst15*gconst2*gconst9))+((gconst21*gconst3*gconst6*gconst8))+(((-1.0)*gconst0*gconst15*gconst19*gconst4))+(((-1.0)*gconst11*gconst12*gconst7*gconst8))+(((-1.0)*gconst18*gconst5*gconst6*gconst9))+(((-1.0)*gconst13*gconst17*gconst2*gconst6))+(((-1.0)*gconst1*gconst14*gconst18*gconst5))+((gconst0*gconst13*gconst22*gconst3))+((gconst18*gconst4*gconst7*gconst9))+(((-0.005102955)*gconst22*gconst9))+((gconst0*gconst11*gconst21*gconst6))+((gconst10*gconst15*gconst4*gconst9))+((gconst22*gconst3*gconst5*gconst8))+((gconst13*gconst16*gconst3*gconst6))+(((-1.0)*gconst12*gconst16*gconst3*gconst7))+(((-1.0)*gconst12*gconst15*gconst3*gconst8))+(((-1.0)*gconst10*gconst14*gconst5*gconst9))+(((-1.0)*gconst20*gconst3*gconst7*gconst8))+(((-1.0)*gconst0*gconst11*gconst23*gconst4))+((gconst2*gconst20*gconst7*gconst9))+((gconst10*gconst12*gconst7*gconst9))+(((-1.0)*gconst13*gconst14*gconst2*gconst9))+((gconst11*gconst14*gconst5*gconst8))+((gconst1*gconst10*gconst20*gconst7))+(((-1.0)*gconst0*gconst11*gconst20*gconst7))+(((-0.00845)*gconst4*gconst9))+((gconst12*gconst17*gconst2*gconst7))+((gconst11*gconst13*gconst6*gconst8))+(((-1.0)*gconst11*gconst15*gconst4*gconst8))+(((-0.006163349049)*gconst11*gconst22))+((gconst14*gconst16*gconst3*gconst5))+(((-1.0)*gconst1*gconst10*gconst22*gconst5))+(((-1.0)*gconst0*gconst11*gconst12*gconst15)));
op[6]=((((-1.0)*gconst13*x126*x127))+(((-0.00845)*x120))+((x161*x176))+(((-1.0)*x152*x195))+(((-1.0)*gconst4*x134*x140))+(((-1.0)*x161*x193))+(((-1.0)*x152*x156))+((gconst22*gconst3*x122))+(((-1.0)*x134*x158))+((x144*x150))+(((-1.0)*x134*x162))+((x120*x160))+((x120*x175))+((x128*x144))+(((-0.012326698098)*x174))+((x162*x167))+(((-1.0)*gconst5*x126*x151))+(((-1.0)*gconst17*x126*x131))+(((-1.0)*x196))+((x122*x136))+(((-1.0)*x142*x167))+((gconst14*gconst5*x164))+(((-1.0)*gconst5*x126*x169))+(((-1.0)*gconst9*x131*x177))+((x122*x129))+(((-0.01020591)*gconst3*gconst4))+((gconst0*gconst13*x121))+((gconst5*gconst8*x121))+(((-1.0)*gconst5*x127*x177))+(((-1.0)*x131*x168))+((x164*x178))+((x156*x171))+(((-0.01020591)*x139))+((x134*x135))+((x127*x156))+((gconst10*gconst4*x163))+(((-1.0)*gconst13*x126*x171))+((gconst18*gconst7*x120))+((x134*x142))+(((-1.0)*x156*x164))+(((-1.0)*x164*x195))+(((-1.0)*x137*x193))+(((-1.0)*gconst2*x125*x139))+((x158*x167))+(((-1.0)*x179*x193)));
op[7]=(((gconst10*gconst7*x120))+((x121*x122))+(((-1.0)*x152*x193))+((x144*x163))+(((-1.0)*gconst1*x131*x177))+(((-1.0)*x134*x156))+(((-1.0)*gconst1*x130))+((gconst14*gconst3*x122))+(((-0.006163349049)*x121))+(((-1.0)*gconst9*x173))+((x156*x167))+((gconst15*gconst2*x120))+(((-1.0)*gconst9*x126*x131))+((x164*x176))+(((-1.0)*gconst3*x153))+(((-1.0)*gconst5*x126*x127))+(((-1.0)*gconst13*x126*x167))+(((-1.0)*x134*x195))+(((-1.0)*gconst6*x157))+(((-1.0)*x164*x193))+(((-1.0)*gconst14*x143))+(((-1.0)*gconst1*x180))+((x134*x178))+(((-1.0)*gconst11*x154)));
op[8]=(((gconst2*gconst7*x120))+((x122*x174))+(((-0.004225)*x120))+(((-0.005102955)*x139))+(((-1.0)*gconst1*x126*x131))+(((-1.0)*gconst3*x154))+(((-1.0)*gconst6*x143))+(((-1.0)*x134*x193)));
polyroots8(op,zeror,numroots);
IkReal j0array[8], cj0array[8], sj0array[8], tempj0array[1];
int numsolutions = 0;
for(int ij0 = 0; ij0 < numroots; ++ij0)
{
IkReal htj0 = zeror[ij0];
tempj0array[0]=((2.0)*(atan(htj0)));
for(int kj0 = 0; kj0 < 1; ++kj0)
{
j0array[numsolutions] = tempj0array[kj0];
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
numsolutions++;
}
}
bool j0valid[8]={true,true,true,true,true,true,true,true};
_nj0 = 8;
for(int ij0 = 0; ij0 < numsolutions; ++ij0)
    {
if( !j0valid[ij0] )
{
    continue;
}
    j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
htj0 = IKtan(j0/2);

_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < numsolutions; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x197=((3.60296738646282)*cj6);
IkReal x198=((0.651021138134535)*cj7);
IkReal x199=(r01*sj0);
IkReal x200=(npz*sj6);
IkReal x201=(cj0*r11);
IkReal x202=((0.063139919395322)*cj7);
IkReal x203=(px*sj0);
IkReal x204=(cj7*npy);
IkReal x205=((3.60296738646282)*sj6);
IkReal x206=(cj0*r12);
IkReal x207=(npx*sj7);
IkReal x208=((24.1647712036406)*cj6);
IkReal x209=((5.32782770551573)*cj6);
IkReal x210=(r02*sj0);
IkReal x211=((0.794379110892395)*sj6);
IkReal x212=((0.794379110892395)*cj6);
IkReal x213=(cj0*py);
IkReal x214=(cj0*r10*sj7);
IkReal x215=(cj7*x212);
IkReal x216=(r00*sj0*sj7);
if( IKabs(((0.878307225753756)+(((-45.4826974440068)*pp))+(((0.651021138134535)*x216))+((x205*x206))+((x197*x216))+((x198*x199))+(((-24.1647712036406)*x200))+(((-1.0)*cj7*x197*x201))+(((4.36633895462465)*x204))+(((4.36633895462465)*x207))+(((-1.0)*x205*x210))+(((-1.15990901777475)*cj6))+(((13.5629403778028)*x213))+((x204*x208))+(((-1.0)*x198*x201))+((cj7*x197*x199))+(((-1.0)*x197*x214))+(((-13.5629403778028)*x203))+(((-0.651021138134535)*x214))+((x207*x208)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.716965130298427)+(((-5.32782770551573)*x200))+(((1.31541498740254)*x213))+(((-1.0)*x201*x202))+((x199*x215))+(((0.423473637795587)*x204))+(((0.423473637795587)*x207))+((x206*x211))+(((-0.255735729864755)*cj6))+((x204*x209))+(((-1.0)*x210*x211))+(((-4.41118372703736)*pp))+((x212*x216))+(((-1.0)*x201*x215))+(((0.063139919395322)*x216))+(((-1.0)*x212*x214))+(((-0.063139919395322)*x214))+((x199*x202))+(((-1.31541498740254)*x203))+((x207*x209)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.878307225753756)+(((-45.4826974440068)*pp))+(((0.651021138134535)*x216))+((x205*x206))+((x197*x216))+((x198*x199))+(((-24.1647712036406)*x200))+(((-1.0)*cj7*x197*x201))+(((4.36633895462465)*x204))+(((4.36633895462465)*x207))+(((-1.0)*x205*x210))+(((-1.15990901777475)*cj6))+(((13.5629403778028)*x213))+((x204*x208))+(((-1.0)*x198*x201))+((cj7*x197*x199))+(((-1.0)*x197*x214))+(((-13.5629403778028)*x203))+(((-0.651021138134535)*x214))+((x207*x208))))+IKsqr(((-0.716965130298427)+(((-5.32782770551573)*x200))+(((1.31541498740254)*x213))+(((-1.0)*x201*x202))+((x199*x215))+(((0.423473637795587)*x204))+(((0.423473637795587)*x207))+((x206*x211))+(((-0.255735729864755)*cj6))+((x204*x209))+(((-1.0)*x210*x211))+(((-4.41118372703736)*pp))+((x212*x216))+(((-1.0)*x201*x215))+(((0.063139919395322)*x216))+(((-1.0)*x212*x214))+(((-0.063139919395322)*x214))+((x199*x202))+(((-1.31541498740254)*x203))+((x207*x209))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((0.878307225753756)+(((-45.4826974440068)*pp))+(((0.651021138134535)*x216))+((x205*x206))+((x197*x216))+((x198*x199))+(((-24.1647712036406)*x200))+(((-1.0)*cj7*x197*x201))+(((4.36633895462465)*x204))+(((4.36633895462465)*x207))+(((-1.0)*x205*x210))+(((-1.15990901777475)*cj6))+(((13.5629403778028)*x213))+((x204*x208))+(((-1.0)*x198*x201))+((cj7*x197*x199))+(((-1.0)*x197*x214))+(((-13.5629403778028)*x203))+(((-0.651021138134535)*x214))+((x207*x208))), ((-0.716965130298427)+(((-5.32782770551573)*x200))+(((1.31541498740254)*x213))+(((-1.0)*x201*x202))+((x199*x215))+(((0.423473637795587)*x204))+(((0.423473637795587)*x207))+((x206*x211))+(((-0.255735729864755)*cj6))+((x204*x209))+(((-1.0)*x210*x211))+(((-4.41118372703736)*pp))+((x212*x216))+(((-1.0)*x201*x215))+(((0.063139919395322)*x216))+(((-1.0)*x212*x214))+(((-0.063139919395322)*x214))+((x199*x202))+(((-1.31541498740254)*x203))+((x207*x209))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x217=IKcos(j4);
IkReal x218=IKsin(j4);
IkReal x219=((0.0143136)*cj7);
IkReal x220=(r01*sj0);
IkReal x221=((0.1491)*sj6);
IkReal x222=(cj7*npy);
IkReal x223=((1.0)*cj6);
IkReal x224=(cj0*r11);
IkReal x225=(npx*sj7);
IkReal x226=((0.0143136)*sj7);
IkReal x227=(cj0*r10);
IkReal x228=(r00*sj0);
IkReal x229=((0.1491)*cj6*cj7);
IkReal x230=((0.1491)*cj6*sj7);
evalcond[0]=((-0.16212314)+(((0.0392535)*x218))+(((-0.096)*x225))+(((-0.096)*x222))+(((-0.2982)*cj0*py))+(((-0.17803726)*x217))+(((-1.0)*x219*x220))+((x219*x224))+pp+(((0.2982)*px*sj0))+((x226*x227))+(((-1.0)*x226*x228)));
evalcond[1]=((0.2688)+((x224*x229))+(((0.3351)*x217))+(((-1.0)*cj0*r12*x221))+((npz*sj6))+(((-1.0)*x222*x223))+(((0.048)*cj6))+(((-1.0)*x223*x225))+(((-1.0)*x220*x229))+((r02*sj0*x221))+((x227*x230))+(((-1.0)*x228*x230))+(((-0.0325)*x218)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x231 = IKatan2WithCheck(IkReal(((((0.04996341)*cj0*cj7*r10*sj4))+(((-0.00484575)*r01*sj0*sj7))+(((-0.0325)*cj4*cj7*npx))+(((-0.00484575)*cj4*cj7*r00*sj0))+(((0.00484575)*cj0*cj4*cj7*r10))+(((-0.00484575)*cj0*cj7*r10))+(((0.04996341)*r01*sj0*sj4*sj7))+(((0.00484575)*cj7*r00*sj0))+(((-0.3351)*cj7*npx*sj4))+(((-0.00484575)*cj0*cj4*r11*sj7))+(((-0.04996341)*cj7*r00*sj0*sj4))+(((0.0325)*cj4*npy*sj7))+(((0.0325)*cj7*npx))+(((0.00484575)*cj0*r11*sj7))+(((0.3351)*npy*sj4*sj7))+(((-0.04996341)*cj0*r11*sj4*sj7))+(((0.00484575)*cj4*r01*sj0*sj7))+(((-0.0325)*npy*sj7)))),IkReal(((((-0.00484575)*cj0*cj4*cj7*r11*sj6))+(((0.00484575)*cj4*r00*sj0*sj6*sj7))+(((0.04996341)*cj6*r02*sj0*sj4))+(((0.00484575)*cj0*r10*sj6*sj7))+(((0.0325)*cj4*cj7*npy*sj6))+(((0.3351)*cj6*npz*sj4))+(((-0.0325)*npx*sj6*sj7))+(((0.04996341)*cj7*r01*sj0*sj4*sj6))+(((-0.00156)*cj4*sj6))+(((-0.00484575)*cj7*r01*sj0*sj6))+(((-0.04996341)*cj0*cj6*r12*sj4))+(((-0.00484575)*cj0*cj4*cj6*r12))+(((-0.0325)*cj6*npz))+(((0.04996341)*r00*sj0*sj4*sj6*sj7))+(((0.3351)*cj7*npy*sj4*sj6))+(((0.00484575)*cj4*cj6*r02*sj0))+(((-0.0160848)*sj4*sj6))+(((-0.0325)*cj7*npy*sj6))+(((-0.00484575)*r00*sj0*sj6*sj7))+(((0.00484575)*cj0*cj7*r11*sj6))+(((0.00484575)*cj4*cj7*r01*sj0*sj6))+(((0.0325)*cj4*cj6*npz))+(((0.00156)*sj6))+(((0.3351)*npx*sj4*sj6*sj7))+(((0.0325)*cj4*npx*sj6*sj7))+(((-0.00484575)*cj0*cj4*r10*sj6*sj7))+(((-0.00484575)*cj6*r02*sj0))+(((0.00484575)*cj0*cj6*r12))+(((-0.04996341)*cj0*r10*sj4*sj6*sj7))+(((-0.04996341)*cj0*cj7*r11*sj4*sj6)))),IKFAST_ATAN2_MAGTHRESH);
if(!x231.valid){
continue;
}
CheckValue<IkReal> x232=IKPowWithIntegerCheck(IKsign(((-0.002304)+(((0.04446162)*cj0*r00*r10*sj0*(cj6*cj6)*(cj7*cj7)))+(((-0.2982)*npz*r02*sj0*(cj6*cj6)))+(((cj6*cj6)*(npx*npx)))+(((0.0143136)*cj7*r01*sj0))+(((0.0143136)*cj6*r02*sj0*sj6))+(((0.04446162)*cj0*cj6*cj7*r02*r11*sj0*sj6))+(((-0.04446162)*cj0*r01*r11*sj0*(cj6*cj6)*(cj7*cj7)))+(((0.2982)*cj0*npz*r12*(cj6*cj6)))+(((-0.02223081)*(r00*r00)))+(((0.02223081)*(cj6*cj6)*(r00*r00)))+(((0.2982)*cj0*cj6*npx*r12*sj6*sj7))+(((0.002304)*(cj6*cj6)))+(((-1.0)*(cj6*cj6)*(cj7*cj7)*(npx*npx)))+(((-1.0)*(npy*npy)))+(((0.04446162)*cj0*r01*r11*sj0))+(((-0.2982)*cj0*cj7*npy*r10*sj7*(cj6*cj6)))+(((0.096)*cj7*npy))+(((0.2982)*cj0*cj6*cj7*npz*r11*sj6))+(((-0.02223081)*(cj0*cj0)*(cj6*cj6)*(cj7*cj7)*(r10*r10)))+(((-0.02223081)*(cj0*cj0)*(r11*r11)))+(((0.04446162)*cj0*cj6*cj7*r01*r12*sj0*sj6))+(((-0.2982)*npx*r00*sj0*(cj6*cj6)*(cj7*cj7)))+(((-0.0143136)*cj7*r01*sj0*(cj6*cj6)))+(((-0.2982)*cj0*npy*r11*(cj6*cj6)*(cj7*cj7)))+(((-0.04446162)*cj6*cj7*r01*r02*sj6))+(((0.04446162)*cj0*r02*r12*sj0*(cj6*cj6)))+(((0.04446162)*cj0*cj6*r02*r10*sj0*sj6*sj7))+(((-0.2982)*cj6*npz*r00*sj0*sj6*sj7))+(((0.02223081)*(cj0*cj0)*(cj6*cj6)*(r10*r10)))+(((0.04446162)*cj0*cj6*r00*r12*sj0*sj6*sj7))+(((0.2982)*cj0*cj6*cj7*npy*r12*sj6))+(((-1.0)*(npx*npx)))+(((-2.0)*cj6*npx*npz*sj6*sj7))+(((-0.096)*cj7*npy*(cj6*cj6)))+(((0.02223081)*(cj0*cj0)*(cj6*cj6)*(cj7*cj7)*(r00*r00)))+(((0.2982)*cj0*cj6*npz*r10*sj6*sj7))+(((-2.0)*cj6*cj7*npy*npz*sj6))+(((-0.02223081)*(cj6*cj6)*(r02*r02)))+(((-0.2982)*cj0*npx*r10*(cj6*cj6)))+(((-0.04446162)*cj0*r00*r10*sj0*(cj6*cj6)))+(((0.0143136)*r00*sj0*sj7))+(((-0.04446162)*cj6*cj7*r11*r12*sj6*(cj0*cj0)))+(((-0.2982)*npx*r00*sj0))+(((0.02223081)*(cj6*cj6)*(cj7*cj7)*(r01*r01)))+(((-0.0143136)*cj0*r10*sj7))+(((-0.02223081)*(cj0*cj0)*(r10*r10)))+(((-0.02223081)*(cj0*cj0)*(cj6*cj6)*(cj7*cj7)*(r01*r01)))+(((0.2982)*cj0*npy*r11))+(((-1.0)*(cj6*cj6)*(npz*npz)))+(((2.0)*cj7*npx*npy*sj7*(cj6*cj6)))+(((-0.096)*npx*sj7*(cj6*cj6)))+(((-0.0143136)*r00*sj0*sj7*(cj6*cj6)))+(((0.2982)*cj0*npx*r10))+(((0.2982)*npx*r00*sj0*(cj6*cj6)))+(((0.0143136)*cj0*cj7*r11*(cj6*cj6)))+(((-0.02223081)*(cj6*cj6)*(cj7*cj7)*(r00*r00)))+(((-0.0143136)*cj0*cj7*r11))+(((-0.2982)*cj6*cj7*npz*r01*sj0*sj6))+(((0.2982)*cj7*npx*r01*sj0*sj7*(cj6*cj6)))+(((-0.2982)*cj6*cj7*npy*r02*sj0*sj6))+(((-0.0143136)*cj0*cj6*r12*sj6))+(((0.2982)*cj7*npy*r00*sj0*sj7*(cj6*cj6)))+(((-0.04446162)*cj6*r00*r02*sj6*sj7))+(((0.04446162)*cj0*r00*r10*sj0))+(((-0.04446162)*cj0*cj7*r01*r10*sj0*sj7*(cj6*cj6)))+(((0.096)*npx*sj7))+(((-0.2982)*npy*r01*sj0))+(((0.02223081)*(cj0*cj0)*(r01*r01)))+(((0.04446162)*cj7*r10*r11*sj7*(cj0*cj0)*(cj6*cj6)))+(((-0.2982)*cj6*npx*r02*sj0*sj6*sj7))+(((cj6*cj6)*(cj7*cj7)*(npy*npy)))+(((0.02223081)*(cj0*cj0)*(r00*r00)))+(((-0.2982)*cj0*cj7*npx*r11*sj7*(cj6*cj6)))+(((0.0143136)*cj0*r10*sj7*(cj6*cj6)))+(((0.02223081)*(cj0*cj0)*(cj6*cj6)*(cj7*cj7)*(r11*r11)))+(((0.04446162)*cj6*cj7*r01*r02*sj6*(cj0*cj0)))+(((-0.04446162)*cj7*r00*r01*sj7*(cj0*cj0)*(cj6*cj6)))+(((-0.02223081)*(cj0*cj0)*(cj6*cj6)*(r00*r00)))+(((0.02223081)*(cj0*cj0)*(cj6*cj6)*(r02*r02)))+(((0.2982)*npy*r01*sj0*(cj6*cj6)*(cj7*cj7)))+(((-0.04446162)*cj0*cj7*r00*r11*sj0*sj7*(cj6*cj6)))+(((-0.02223081)*(cj0*cj0)*(cj6*cj6)*(r12*r12)))+(((-0.04446162)*cj6*r10*r12*sj6*sj7*(cj0*cj0)))+(((0.096)*cj6*npz*sj6))+(((0.04446162)*cj6*r00*r02*sj6*sj7*(cj0*cj0)))+(((0.2982)*cj0*npx*r10*(cj6*cj6)*(cj7*cj7)))+(((0.04446162)*cj7*r00*r01*sj7*(cj6*cj6)))+(((-0.02223081)*(r01*r01))))),-1);
if(!x232.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(x231.value)+(((1.5707963267949)*(x232.value))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x233=IKcos(j5);
IkReal x234=IKsin(j5);
IkReal x235=(cj6*sj4);
IkReal x236=((0.048)*cj7);
IkReal x237=((0.6702)*sj4);
IkReal x238=(cj6*r02);
IkReal x239=((0.0325)*sj7);
IkReal x240=(cj6*cj7);
IkReal x241=((0.3351)*cj4);
IkReal x242=((0.0325)*r00);
IkReal x243=((0.1491)*sj0);
IkReal x244=((0.065)*npx);
IkReal x245=((0.3351)*sj4);
IkReal x246=((0.0325)*cj7);
IkReal x247=((0.065)*cj4);
IkReal x248=(r22*sj6);
IkReal x249=(r02*sj6);
IkReal x250=(cj4*r11);
IkReal x251=(npz*sj6);
IkReal x252=((0.6702)*cj4);
IkReal x253=(cj6*sj7);
IkReal x254=(cj4*r21);
IkReal x255=((0.0325)*sj4);
IkReal x256=(r00*sj7);
IkReal x257=((1.0)*npx);
IkReal x258=(cj7*sj6);
IkReal x259=((0.1491)*cj0);
IkReal x260=(cj0*r11);
IkReal x261=((0.0325)*cj4);
IkReal x262=(r01*sj0);
IkReal x263=((0.048)*sj7);
IkReal x264=(cj7*npy);
IkReal x265=(cj7*r10);
IkReal x266=(r12*sj6);
IkReal x267=(sj4*sj6);
IkReal x268=(cj7*r00);
IkReal x269=((0.1491)*x234);
IkReal x270=(r10*sj6*sj7);
IkReal x271=((0.3351)*x233);
IkReal x272=(r01*x234);
IkReal x273=(cj7*x234);
IkReal x274=(sj6*x233);
IkReal x275=(sj7*x233);
IkReal x276=(sj7*x234);
IkReal x277=(r11*x259);
IkReal x278=(cj6*x233);
IkReal x279=((0.0325)*x233);
IkReal x280=(npy*x276);
IkReal x281=(cj4*x273);
IkReal x282=(r20*x273);
IkReal x283=(npx*sj7*x274);
IkReal x284=(npy*x233*x258);
IkReal x285=((0.065)*npz*x278);
evalcond[0]=(((cj6*r12*x234*x259))+((x234*x259*x270))+(((-1.0)*cj6*npz*x234))+(((-1.0)*x234*x238*x243))+(((0.048)*sj6*x234))+(((-1.0)*x233*x243*x268))+(((-1.0)*npy*x234*x258))+(((-1.0)*x243*x258*x272))+(((-1.0)*cj7*x233*x257))+((npy*x275))+(((-1.0)*sj6*x257*x276))+(((-1.0)*x275*x277))+((r01*x243*x275))+((x233*x259*x265))+(((-1.0)*sj6*x234*x243*x256))+((x234*x258*x277)));
evalcond[1]=((-0.0325)+((sj7*x243*x272))+(((-1.0)*x234*x243*x268))+((x234*x259*x265))+(((-0.048)*x274))+(((-1.0)*x233*x259*x270))+x261+x245+x284+x283+x280+((npz*x278))+(((-1.0)*x257*x273))+((r01*x233*x243*x258))+(((-1.0)*r12*x259*x278))+(((-1.0)*x233*x258*x277))+((x233*x238*x243))+(((-1.0)*x276*x277))+((x243*x256*x274)));
evalcond[2]=(((r20*x241*x253))+(((0.2688)*r21*x240))+((x248*x255))+(((-1.0)*r20*sj7*x245*x274))+(((-1.0)*r21*x233*x245*x258))+(((-1.0)*r20*x234*x246))+(((-1.0)*r20*x235*x239))+(((-1.0)*r21*x235*x246))+((cj4*r20*x234*x246))+(((0.0325)*r22*x278))+((r21*x234*x239))+(((-1.0)*x234*x239*x254))+((r21*x246*x274))+(((-1.0)*cj4*r20*x239*x274))+(((-1.0)*pz))+(((-1.0)*x241*x248))+(((-1.0)*x246*x254*x274))+((r20*x239*x274))+(((-1.0)*r22*x261*x278))+(((0.2688)*r20*x253))+((r21*x240*x241))+((r21*x236))+((x245*x282))+(((-0.2688)*x248))+(((-1.0)*r21*x245*x276))+(((-1.0)*r22*x235*x271))+((r20*x263)));
evalcond[3]=((((-1.0)*x242*x273))+(((-1.0)*cj4*r01*x246*x274))+(((-1.0)*x245*x256*x274))+(((-1.0)*r00*x235*x239))+((x249*x255))+(((-1.0)*r01*x235*x246))+((x242*x281))+(((-1.0)*r02*x235*x271))+(((-1.0)*sj7*x245*x272))+((x238*x279))+(((-1.0)*cj4*x239*x272))+(((-1.0)*x233*x238*x261))+(((-1.0)*r01*x233*x245*x258))+((x239*x272))+(((-1.0)*px))+(((-1.0)*cj4*r00*x239*x274))+(((-1.0)*x241*x249))+(((0.048)*x256))+((r01*x236))+((r01*x246*x274))+((r01*x240*x241))+(((0.2688)*r00*x253))+(((-1.0)*x243))+((x234*x245*x268))+((r00*x241*x253))+(((0.2688)*r01*x240))+(((-0.2688)*x249))+((r00*x239*x274)));
evalcond[4]=(((r11*x236))+(((-1.0)*x246*x250*x274))+((r10*x239*x274))+(((-1.0)*r10*x234*x246))+(((-1.0)*r12*x235*x271))+(((-1.0)*r11*x245*x276))+((cj4*r10*x234*x246))+(((0.2688)*r11*x240))+(((0.0325)*r12*x278))+(((0.2688)*r10*x253))+(((-1.0)*cj4*r10*x239*x274))+(((-1.0)*x234*x239*x250))+(((-1.0)*x241*x266))+(((-1.0)*py))+x259+((x255*x266))+(((-1.0)*r12*x261*x278))+((r11*x234*x239))+(((-1.0)*r11*x233*x245*x258))+((r10*x241*x253))+((r10*x263))+((r11*x240*x241))+((x234*x245*x265))+(((-0.2688)*x266))+((r11*x246*x274))+(((-1.0)*r10*x235*x239))+(((-1.0)*r11*x235*x246))+(((-1.0)*x233*x245*x270)));
evalcond[5]=((-0.16673114)+(((-0.17803726)*cj4))+(((0.00312)*x235))+(((-1.0)*npz*x247*x278))+(((-1.0)*cj4*sj7*x244*x274))+(((0.0392535)*sj4))+(((-1.0)*x237*x283))+(((-1.0)*x237*x284))+(((-1.0)*x237*x280))+((npx*x237*x273))+(((-1.0)*x251*x252))+(((0.00312)*cj4*x274))+(((-1.0)*sj7*x235*x244))+((npy*x240*x252))+(((0.096)*x264))+((x244*x281))+(((-0.0258048)*cj6))+(((0.065)*x284))+(((0.065)*x280))+(((-0.6702)*npz*x233*x235))+(((-0.0321696)*cj4*cj6))+(((-1.0)*pp))+x285+(((0.065)*sj4*x251))+(((0.5376)*npx*x253))+(((0.0321696)*x233*x267))+(((-1.0)*x247*x280))+(((-1.0)*x247*x284))+(((-0.065)*x235*x264))+(((0.096)*npx*sj7))+(((-0.00312)*x274))+(((0.5376)*npy*x240))+((sj7*x244*x274))+(((-0.5376)*x251))+((npx*x252*x253))+(((-1.0)*x244*x273)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}
}
}
    }
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x286=((1.0)*sj4);
IkReal x287=((1.0)*cj0);
IkReal x288=((1.0)*sj7);
IkReal x289=((1.0)*cj7);
IkReal x290=((1.0)*sj0);
IkReal x291=((1.0)*sj6);
IkReal x292=((1.0)*sj5);
IkReal x293=((-1.0)*sj6);
IkReal x294=(((r11*sj0))+((cj0*r01)));
IkReal x295=(((r10*sj0))+((cj0*r00)));
IkReal x296=(((r21*sj7))+(((-1.0)*r20*x289)));
IkReal x297=(((cj0*r11))+(((-1.0)*r01*x290)));
IkReal x298=((((-1.0)*r00*x290))+((cj0*r10)));
IkReal x299=(((r02*sj0))+(((-1.0)*r12*x287)));
IkReal x300=(cj7*x298);
IkReal x301=((((-1.0)*r02*x287))+(((-1.0)*r12*x290)));
IkReal x302=((((-1.0)*r21*x289))+(((-1.0)*r20*x288)));
IkReal x303=(cj6*x301);
IkReal x304=(((cj6*r22))+(((-1.0)*x291*x302)));
IkReal x305=(((r22*sj6))+((cj6*x302)));
IkReal x306=((((-1.0)*x288*x294))+((cj7*x295)));
IkReal x307=(((cj7*x294))+((sj7*x295)));
IkReal x308=(((cj7*x297))+((sj7*x298)));
IkReal x309=(sj5*x306);
IkReal x310=(((sj5*x296))+((cj5*x304)));
IkReal x311=(((cj6*x308))+((sj6*x299)));
IkReal x312=(((cj6*x299))+((x293*x308)));
IkReal x313=(x303+(((-1.0)*x291*x307)));
IkReal x314=(((cj6*x307))+((sj6*x301)));
IkReal x315=(((cj5*x312))+((sj5*((x300+(((-1.0)*sj7*x297)))))));
new_r00=((((-1.0)*x292*x313))+((cj5*x306)));
new_r01=(((cj4*((((cj5*x313))+x309))))+(((-1.0)*x286*x314)));
new_r02=(((cj4*x314))+((sj4*((x309+((cj5*((x303+((x293*x307)))))))))));
new_r10=((((-1.0)*x292*x304))+((cj5*x296)));
new_r11=(((cj4*x310))+(((-1.0)*x286*x305)));
new_r12=(((sj4*x310))+((cj4*x305)));
new_r20=((((-1.0)*x292*x312))+((cj5*((x300+(((-1.0)*x288*x297)))))));
new_r21=((((-1.0)*x286*x311))+((cj4*x315)));
new_r22=(((cj4*x311))+((sj4*x315)));
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
cj2array[0]=new_r22;
if( cj2array[0] >= -1-IKFAST_SINCOS_THRESH && cj2array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j2valid[0] = j2valid[1] = true;
    j2array[0] = IKacos(cj2array[0]);
    sj2array[0] = IKsin(j2array[0]);
    cj2array[1] = cj2array[0];
    j2array[1] = -j2array[0];
    sj2array[1] = -sj2array[0];
}
else if( isnan(cj2array[0]) )
{
    // probably any value will work
    j2valid[0] = true;
    cj2array[0] = 1; sj2array[0] = 0; j2array[0] = 0;
}
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal j3eval[3];
j3eval[0]=sj2;
j3eval[1]=IKsign(sj2);
j3eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
j1eval[0]=sj2;
j1eval[1]=IKsign(sj2);
j1eval[2]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
j1eval[0]=new_r02;
j1eval[1]=sj2;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j3mul = 1;
j3=0;
j1mul=-1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1=IKatan2(((-1.0)*new_r01), new_r00);
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].fmul = j1mul;
vinfos[1].freeind = 0;
vinfos[1].maxsolutions = 0;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].fmul = j3mul;
vinfos[3].freeind = 0;
vinfos[3].maxsolutions = 0;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(1);
vfree[0] = 3;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j3mul = 1;
j3=0;
j1mul=1.0;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1=IKatan2(new_r01, ((-1.0)*new_r11));
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].fmul = j1mul;
vinfos[1].freeind = 0;
vinfos[1].maxsolutions = 0;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].fmul = j3mul;
vinfos[3].freeind = 0;
vinfos[3].maxsolutions = 0;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(1);
vfree[0] = 3;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
IkReal x316=new_r22*new_r22;
IkReal x317=((16.0)*new_r10);
IkReal x318=((16.0)*new_r01);
IkReal x319=((16.0)*new_r00);
IkReal x320=(new_r11*new_r22);
IkReal x321=((8.0)*new_r00);
IkReal x322=(x316*x317);
IkReal x323=(x316*x318);
j1eval[0]=((IKabs(((((-32.0)*new_r11*x316))+(((16.0)*new_r11))+((new_r22*x319)))))+(IKabs((((new_r22*x321))+(((-8.0)*new_r11)))))+(IKabs(((((-1.0)*x322))+x317)))+(IKabs((x323+(((-1.0)*x318)))))+(IKabs(((((-1.0)*x323))+x318)))+(IKabs(((((32.0)*new_r00))+(((-16.0)*x320))+(((-1.0)*x316*x319)))))+(IKabs((((x316*x321))+(((-8.0)*x320)))))+(IKabs((x322+(((-1.0)*x317))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j3]

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal j1evalpoly[1];
IkReal x324=new_r22*new_r22;
IkReal x325=((16.0)*new_r01);
IkReal x326=(new_r00*new_r22);
IkReal x327=(x324*x325);
IkReal x328=((((8.0)*x326))+(((-8.0)*new_r11)));
op[0]=x328;
op[1]=((((-1.0)*x325))+x327);
op[2]=((((-32.0)*new_r11*x324))+(((16.0)*new_r11))+(((16.0)*x326)));
op[3]=((((-1.0)*x327))+x325);
op[4]=x328;
polyroots4(op,zeror,numroots);
IkReal j1array[4], cj1array[4], sj1array[4], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[4]={true,true,true,true};
_nj1 = 4;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x329=new_r22*new_r22;
IkReal x330=((16.0)*new_r10);
IkReal x331=(new_r11*new_r22);
IkReal x332=((8.0)*x331);
IkReal x333=(new_r00*x329);
IkReal x334=((8.0)*x333);
IkReal x335=(x329*x330);
j1evalpoly[0]=((((htj1*htj1*htj1)*((x330+(((-1.0)*x335))))))+x334+(((htj1*htj1*htj1*htj1)*((x334+(((-1.0)*x332))))))+(((-1.0)*x332))+(((htj1*htj1)*(((((32.0)*new_r00))+(((-16.0)*x331))+(((-16.0)*x333))))))+((htj1*((x335+(((-1.0)*x330)))))));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j3eval[3];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
IkReal x336=new_r22*new_r22;
IkReal x337=cj1*cj1;
IkReal x338=(new_r22*sj1);
IkReal x339=(((x336*x337))+(((-1.0)*x337))+(((-1.0)*x336)));
j3eval[0]=x339;
j3eval[1]=((IKabs((((new_r01*x338))+(((-1.0)*cj1*new_r00)))))+(IKabs((((new_r00*x338))+((cj1*new_r01))))));
j3eval[2]=IKsign(x339);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j3eval[0]=new_r22;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j3eval[0]=cj1;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-1.0)*new_r11), new_r10);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x340=IKsin(j3);
IkReal x341=IKcos(j3);
evalcond[0]=(x340+new_r11);
evalcond[1]=((-1.0)*x340);
evalcond[2]=((-1.0)*x341);
evalcond[3]=(new_r10+(((-1.0)*x341)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(new_r11, ((-1.0)*new_r10));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x342=IKsin(j3);
IkReal x343=IKcos(j3);
evalcond[0]=((-1.0)*x342);
evalcond[1]=((-1.0)*x343);
evalcond[2]=(x342+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*new_r10))+(((-1.0)*x343)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x344=new_r22*new_r22;
CheckValue<IkReal> x345=IKPowWithIntegerCheck(((-1.0)+x344),-1);
if(!x345.valid){
continue;
}
if(((x344*(x345.value))) < -0.00001)
continue;
IkReal gconst46=IKsqrt((x344*(x345.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst46))+cj1)))+(IKabs(((-1.0)+(IKsign(sj1)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
IkReal x346=new_r22*new_r22;
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
if((((1.0)+(((-1.0)*(gconst46*gconst46))))) < -0.00001)
continue;
sj1=IKsqrt(((1.0)+(((-1.0)*(gconst46*gconst46)))));
cj1=gconst46;
if( (gconst46) < -1-IKFAST_SINCOS_THRESH || (gconst46) > 1+IKFAST_SINCOS_THRESH )
    continue;
j1=IKacos(gconst46);
CheckValue<IkReal> x347=IKPowWithIntegerCheck(((-1.0)+x346),-1);
if(!x347.valid){
continue;
}
if(((x346*(x347.value))) < -0.00001)
continue;
IkReal gconst46=IKsqrt((x346*(x347.value)));
j3eval[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if((((1.0)+(((-1.0)*(gconst46*gconst46))))) < -0.00001)
continue;
CheckValue<IkReal> x348=IKPowWithIntegerCheck(gconst46,-1);
if(!x348.valid){
continue;
}
if( IKabs(((((-1.0)*gconst46*new_r01))+(((-1.0)*new_r11*(IKsqrt(((1.0)+(((-1.0)*(gconst46*gconst46)))))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r00*(x348.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*gconst46*new_r01))+(((-1.0)*new_r11*(IKsqrt(((1.0)+(((-1.0)*(gconst46*gconst46))))))))))+IKsqr((new_r00*(x348.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*gconst46*new_r01))+(((-1.0)*new_r11*(IKsqrt(((1.0)+(((-1.0)*(gconst46*gconst46))))))))), (new_r00*(x348.value)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x349=IKsin(j3);
IkReal x350=IKcos(j3);
IkReal x351=((1.0)*x350);
if((((1.0)+(((-1.0)*(gconst46*gconst46))))) < -0.00001)
continue;
IkReal x352=IKsqrt(((1.0)+(((-1.0)*(gconst46*gconst46)))));
evalcond[0]=((-1.0)*x349);
evalcond[1]=((-1.0)*x350);
evalcond[2]=(((gconst46*x349))+new_r01);
evalcond[3]=((((-1.0)*gconst46*x351))+new_r00);
evalcond[4]=(((x349*x352))+new_r11);
evalcond[5]=((((-1.0)*x351*x352))+new_r10);
evalcond[6]=(((gconst46*new_r01))+x349+((new_r11*x352)));
evalcond[7]=(((gconst46*new_r00))+(((-1.0)*x351))+((new_r10*x352)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x353 = IKatan2WithCheck(IkReal(((-1.0)*new_r01)),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x353.valid){
continue;
}
CheckValue<IkReal> x354=IKPowWithIntegerCheck(IKsign(gconst46),-1);
if(!x354.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x353.value)+(((1.5707963267949)*(x354.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x355=IKsin(j3);
IkReal x356=IKcos(j3);
IkReal x357=((1.0)*x356);
if((((1.0)+(((-1.0)*(gconst46*gconst46))))) < -0.00001)
continue;
IkReal x358=IKsqrt(((1.0)+(((-1.0)*(gconst46*gconst46)))));
evalcond[0]=((-1.0)*x355);
evalcond[1]=((-1.0)*x356);
evalcond[2]=(((gconst46*x355))+new_r01);
evalcond[3]=((((-1.0)*gconst46*x357))+new_r00);
evalcond[4]=(((x355*x358))+new_r11);
evalcond[5]=((((-1.0)*x357*x358))+new_r10);
evalcond[6]=(((gconst46*new_r01))+x355+((new_r11*x358)));
evalcond[7]=(((gconst46*new_r00))+(((-1.0)*x357))+((new_r10*x358)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x359=new_r22*new_r22;
CheckValue<IkReal> x360=IKPowWithIntegerCheck(((-1.0)+x359),-1);
if(!x360.valid){
continue;
}
if(((x359*(x360.value))) < -0.00001)
continue;
IkReal gconst46=IKsqrt((x359*(x360.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst46))+cj1)))+(IKabs(((1.0)+(IKsign(sj1)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
IkReal x361=new_r22*new_r22;
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
if((((1.0)+(((-1.0)*(gconst46*gconst46))))) < -0.00001)
continue;
sj1=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst46*gconst46)))))));
cj1=gconst46;
if( (gconst46) < -1-IKFAST_SINCOS_THRESH || (gconst46) > 1+IKFAST_SINCOS_THRESH )
    continue;
j1=((-1.0)*(IKacos(gconst46)));
CheckValue<IkReal> x362=IKPowWithIntegerCheck(((-1.0)+x361),-1);
if(!x362.valid){
continue;
}
if(((x361*(x362.value))) < -0.00001)
continue;
IkReal gconst46=IKsqrt((x361*(x362.value)));
j3eval[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if((((1.0)+(((-1.0)*(gconst46*gconst46))))) < -0.00001)
continue;
CheckValue<IkReal> x363=IKPowWithIntegerCheck(gconst46,-1);
if(!x363.valid){
continue;
}
if( IKabs(((((-1.0)*gconst46*new_r01))+((new_r11*(IKsqrt(((1.0)+(((-1.0)*(gconst46*gconst46)))))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r00*(x363.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*gconst46*new_r01))+((new_r11*(IKsqrt(((1.0)+(((-1.0)*(gconst46*gconst46))))))))))+IKsqr((new_r00*(x363.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*gconst46*new_r01))+((new_r11*(IKsqrt(((1.0)+(((-1.0)*(gconst46*gconst46))))))))), (new_r00*(x363.value)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x364=IKsin(j3);
IkReal x365=IKcos(j3);
IkReal x366=((1.0)*x365);
if((((1.0)+(((-1.0)*(gconst46*gconst46))))) < -0.00001)
continue;
IkReal x367=IKsqrt(((1.0)+(((-1.0)*(gconst46*gconst46)))));
IkReal x368=((1.0)*x367);
evalcond[0]=((-1.0)*x364);
evalcond[1]=((-1.0)*x365);
evalcond[2]=(((gconst46*x364))+new_r01);
evalcond[3]=((((-1.0)*gconst46*x366))+new_r00);
evalcond[4]=(((x365*x367))+new_r10);
evalcond[5]=((((-1.0)*x364*x368))+new_r11);
evalcond[6]=(((gconst46*new_r01))+x364+(((-1.0)*new_r11*x368)));
evalcond[7]=(((gconst46*new_r00))+(((-1.0)*x366))+(((-1.0)*new_r10*x368)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x369 = IKatan2WithCheck(IkReal(((-1.0)*new_r01)),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x369.valid){
continue;
}
CheckValue<IkReal> x370=IKPowWithIntegerCheck(IKsign(gconst46),-1);
if(!x370.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x369.value)+(((1.5707963267949)*(x370.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x371=IKsin(j3);
IkReal x372=IKcos(j3);
IkReal x373=((1.0)*x372);
if((((1.0)+(((-1.0)*(gconst46*gconst46))))) < -0.00001)
continue;
IkReal x374=IKsqrt(((1.0)+(((-1.0)*(gconst46*gconst46)))));
IkReal x375=((1.0)*x374);
evalcond[0]=((-1.0)*x371);
evalcond[1]=((-1.0)*x372);
evalcond[2]=(((gconst46*x371))+new_r01);
evalcond[3]=((((-1.0)*gconst46*x373))+new_r00);
evalcond[4]=(((x372*x374))+new_r10);
evalcond[5]=((((-1.0)*x371*x375))+new_r11);
evalcond[6]=(((gconst46*new_r01))+x371+(((-1.0)*new_r11*x375)));
evalcond[7]=(((gconst46*new_r00))+(((-1.0)*x373))+(((-1.0)*new_r10*x375)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x376=new_r22*new_r22;
CheckValue<IkReal> x377=IKPowWithIntegerCheck(((-1.0)+x376),-1);
if(!x377.valid){
continue;
}
if(((x376*(x377.value))) < -0.00001)
continue;
IkReal gconst47=((-1.0)*(IKsqrt((x376*(x377.value)))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst47))+cj1)))+(IKabs(((-1.0)+(IKsign(sj1)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
IkReal x378=new_r22*new_r22;
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
if((((1.0)+(((-1.0)*(gconst47*gconst47))))) < -0.00001)
continue;
sj1=IKsqrt(((1.0)+(((-1.0)*(gconst47*gconst47)))));
cj1=gconst47;
if( (gconst47) < -1-IKFAST_SINCOS_THRESH || (gconst47) > 1+IKFAST_SINCOS_THRESH )
    continue;
j1=IKacos(gconst47);
CheckValue<IkReal> x379=IKPowWithIntegerCheck(((-1.0)+x378),-1);
if(!x379.valid){
continue;
}
if(((x378*(x379.value))) < -0.00001)
continue;
IkReal gconst47=((-1.0)*(IKsqrt((x378*(x379.value)))));
j3eval[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if((((1.0)+(((-1.0)*(gconst47*gconst47))))) < -0.00001)
continue;
CheckValue<IkReal> x380=IKPowWithIntegerCheck(gconst47,-1);
if(!x380.valid){
continue;
}
if( IKabs(((((-1.0)*gconst47*new_r01))+(((-1.0)*new_r11*(IKsqrt(((1.0)+(((-1.0)*(gconst47*gconst47)))))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r00*(x380.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*gconst47*new_r01))+(((-1.0)*new_r11*(IKsqrt(((1.0)+(((-1.0)*(gconst47*gconst47))))))))))+IKsqr((new_r00*(x380.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*gconst47*new_r01))+(((-1.0)*new_r11*(IKsqrt(((1.0)+(((-1.0)*(gconst47*gconst47))))))))), (new_r00*(x380.value)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x381=IKsin(j3);
IkReal x382=IKcos(j3);
IkReal x383=((1.0)*x382);
if((((1.0)+(((-1.0)*(gconst47*gconst47))))) < -0.00001)
continue;
IkReal x384=IKsqrt(((1.0)+(((-1.0)*(gconst47*gconst47)))));
evalcond[0]=((-1.0)*x381);
evalcond[1]=((-1.0)*x382);
evalcond[2]=(((gconst47*x381))+new_r01);
evalcond[3]=(new_r00+(((-1.0)*gconst47*x383)));
evalcond[4]=(new_r11+((x381*x384)));
evalcond[5]=(new_r10+(((-1.0)*x383*x384)));
evalcond[6]=(x381+((new_r11*x384))+((gconst47*new_r01)));
evalcond[7]=(((new_r10*x384))+(((-1.0)*x383))+((gconst47*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x385 = IKatan2WithCheck(IkReal(((-1.0)*new_r01)),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x385.valid){
continue;
}
CheckValue<IkReal> x386=IKPowWithIntegerCheck(IKsign(gconst47),-1);
if(!x386.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x385.value)+(((1.5707963267949)*(x386.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x387=IKsin(j3);
IkReal x388=IKcos(j3);
IkReal x389=((1.0)*x388);
if((((1.0)+(((-1.0)*(gconst47*gconst47))))) < -0.00001)
continue;
IkReal x390=IKsqrt(((1.0)+(((-1.0)*(gconst47*gconst47)))));
evalcond[0]=((-1.0)*x387);
evalcond[1]=((-1.0)*x388);
evalcond[2]=(((gconst47*x387))+new_r01);
evalcond[3]=(new_r00+(((-1.0)*gconst47*x389)));
evalcond[4]=(((x387*x390))+new_r11);
evalcond[5]=((((-1.0)*x389*x390))+new_r10);
evalcond[6]=(((new_r11*x390))+x387+((gconst47*new_r01)));
evalcond[7]=((((-1.0)*x389))+((new_r10*x390))+((gconst47*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x391=new_r22*new_r22;
CheckValue<IkReal> x392=IKPowWithIntegerCheck(((-1.0)+x391),-1);
if(!x392.valid){
continue;
}
if(((x391*(x392.value))) < -0.00001)
continue;
IkReal gconst47=((-1.0)*(IKsqrt((x391*(x392.value)))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.0)+(IKsign(sj1)))))+(IKabs(((((-1.0)*gconst47))+cj1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
IkReal x393=new_r22*new_r22;
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
if((((1.0)+(((-1.0)*(gconst47*gconst47))))) < -0.00001)
continue;
sj1=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst47*gconst47)))))));
cj1=gconst47;
if( (gconst47) < -1-IKFAST_SINCOS_THRESH || (gconst47) > 1+IKFAST_SINCOS_THRESH )
    continue;
j1=((-1.0)*(IKacos(gconst47)));
CheckValue<IkReal> x394=IKPowWithIntegerCheck(((-1.0)+x393),-1);
if(!x394.valid){
continue;
}
if(((x393*(x394.value))) < -0.00001)
continue;
IkReal gconst47=((-1.0)*(IKsqrt((x393*(x394.value)))));
j3eval[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if((((1.0)+(((-1.0)*(gconst47*gconst47))))) < -0.00001)
continue;
CheckValue<IkReal> x395=IKPowWithIntegerCheck(gconst47,-1);
if(!x395.valid){
continue;
}
if( IKabs(((((-1.0)*gconst47*new_r01))+((new_r11*(IKsqrt(((1.0)+(((-1.0)*(gconst47*gconst47)))))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r00*(x395.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*gconst47*new_r01))+((new_r11*(IKsqrt(((1.0)+(((-1.0)*(gconst47*gconst47))))))))))+IKsqr((new_r00*(x395.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*gconst47*new_r01))+((new_r11*(IKsqrt(((1.0)+(((-1.0)*(gconst47*gconst47))))))))), (new_r00*(x395.value)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x396=IKsin(j3);
IkReal x397=IKcos(j3);
IkReal x398=((1.0)*x397);
if((((1.0)+(((-1.0)*(gconst47*gconst47))))) < -0.00001)
continue;
IkReal x399=IKsqrt(((1.0)+(((-1.0)*(gconst47*gconst47)))));
IkReal x400=((1.0)*x399);
evalcond[0]=((-1.0)*x396);
evalcond[1]=((-1.0)*x397);
evalcond[2]=(((gconst47*x396))+new_r01);
evalcond[3]=((((-1.0)*gconst47*x398))+new_r00);
evalcond[4]=(((x397*x399))+new_r10);
evalcond[5]=(new_r11+(((-1.0)*x396*x400)));
evalcond[6]=(x396+(((-1.0)*new_r11*x400))+((gconst47*new_r01)));
evalcond[7]=((((-1.0)*x398))+(((-1.0)*new_r10*x400))+((gconst47*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x401 = IKatan2WithCheck(IkReal(((-1.0)*new_r01)),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x401.valid){
continue;
}
CheckValue<IkReal> x402=IKPowWithIntegerCheck(IKsign(gconst47),-1);
if(!x402.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x401.value)+(((1.5707963267949)*(x402.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x403=IKsin(j3);
IkReal x404=IKcos(j3);
IkReal x405=((1.0)*x404);
if((((1.0)+(((-1.0)*(gconst47*gconst47))))) < -0.00001)
continue;
IkReal x406=IKsqrt(((1.0)+(((-1.0)*(gconst47*gconst47)))));
IkReal x407=((1.0)*x406);
evalcond[0]=((-1.0)*x403);
evalcond[1]=((-1.0)*x404);
evalcond[2]=(((gconst47*x403))+new_r01);
evalcond[3]=(new_r00+(((-1.0)*gconst47*x405)));
evalcond[4]=(((x404*x406))+new_r10);
evalcond[5]=((((-1.0)*x403*x407))+new_r11);
evalcond[6]=(x403+(((-1.0)*new_r11*x407))+((gconst47*new_r01)));
evalcond[7]=((((-1.0)*new_r10*x407))+(((-1.0)*x405))+((gconst47*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x408=((1.0)*sj1);
IkReal x409=(cj1*new_r01);
IkReal x410=(new_r11*new_r22);
CheckValue<IkReal> x411=IKPowWithIntegerCheck(cj1,-1);
if(!x411.valid){
continue;
}
if( IKabs(((((-1.0)*new_r11*x408))+(((-1.0)*x409)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x411.value)*((((x410*(cj1*cj1)))+(((-1.0)*new_r22*x408*x409))+new_r00+(((-1.0)*x410)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r11*x408))+(((-1.0)*x409))))+IKsqr(((x411.value)*((((x410*(cj1*cj1)))+(((-1.0)*new_r22*x408*x409))+new_r00+(((-1.0)*x410))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*new_r11*x408))+(((-1.0)*x409))), ((x411.value)*((((x410*(cj1*cj1)))+(((-1.0)*new_r22*x408*x409))+new_r00+(((-1.0)*x410))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[10];
IkReal x412=IKcos(j3);
IkReal x413=IKsin(j3);
IkReal x414=(cj1*new_r22);
IkReal x415=(new_r22*sj1);
IkReal x416=((1.0)*new_r01);
IkReal x417=((1.0)*new_r00);
IkReal x418=((1.0)*x412);
IkReal x419=(cj1*x413);
IkReal x420=((1.0)*x413);
evalcond[0]=(((new_r11*sj1))+((cj1*new_r01))+x413);
evalcond[1]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x418)));
evalcond[2]=(x419+((x412*x415))+new_r01);
evalcond[3]=((((-1.0)*cj1*x418))+((x413*x415))+new_r00);
evalcond[4]=(((sj1*x413))+new_r11+(((-1.0)*x414*x418)));
evalcond[5]=((((-1.0)*new_r22*x420))+((cj1*new_r10))+(((-1.0)*sj1*x417)));
evalcond[6]=(((cj1*new_r11))+(((-1.0)*new_r22*x418))+(((-1.0)*sj1*x416)));
evalcond[7]=((((-1.0)*x414*x420))+new_r10+(((-1.0)*sj1*x418)));
evalcond[8]=((((-1.0)*x420))+(((-1.0)*x415*x417))+((new_r10*x414)));
evalcond[9]=(((new_r11*x414))+(((-1.0)*x415*x416))+(((-1.0)*x418)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x421=((1.0)*new_r01);
CheckValue<IkReal> x422=IKPowWithIntegerCheck(new_r22,-1);
if(!x422.valid){
continue;
}
if( IKabs(((((-1.0)*cj1*x421))+(((-1.0)*new_r11*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x422.value)*(((((-1.0)*sj1*x421))+((cj1*new_r11)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj1*x421))+(((-1.0)*new_r11*sj1))))+IKsqr(((x422.value)*(((((-1.0)*sj1*x421))+((cj1*new_r11))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*cj1*x421))+(((-1.0)*new_r11*sj1))), ((x422.value)*(((((-1.0)*sj1*x421))+((cj1*new_r11))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[10];
IkReal x423=IKcos(j3);
IkReal x424=IKsin(j3);
IkReal x425=(cj1*new_r22);
IkReal x426=(new_r22*sj1);
IkReal x427=((1.0)*new_r01);
IkReal x428=((1.0)*new_r00);
IkReal x429=((1.0)*x423);
IkReal x430=(cj1*x424);
IkReal x431=((1.0)*x424);
evalcond[0]=(((new_r11*sj1))+((cj1*new_r01))+x424);
evalcond[1]=(((new_r10*sj1))+(((-1.0)*x429))+((cj1*new_r00)));
evalcond[2]=(x430+((x423*x426))+new_r01);
evalcond[3]=((((-1.0)*cj1*x429))+((x424*x426))+new_r00);
evalcond[4]=((((-1.0)*x425*x429))+new_r11+((sj1*x424)));
evalcond[5]=((((-1.0)*sj1*x428))+((cj1*new_r10))+(((-1.0)*new_r22*x431)));
evalcond[6]=((((-1.0)*sj1*x427))+(((-1.0)*new_r22*x429))+((cj1*new_r11)));
evalcond[7]=((((-1.0)*sj1*x429))+(((-1.0)*x425*x431))+new_r10);
evalcond[8]=((((-1.0)*x431))+((new_r10*x425))+(((-1.0)*x426*x428)));
evalcond[9]=((((-1.0)*x429))+((new_r11*x425))+(((-1.0)*x426*x427)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x432=new_r22*new_r22;
IkReal x433=cj1*cj1;
IkReal x434=(new_r22*sj1);
CheckValue<IkReal> x435=IKPowWithIntegerCheck(IKsign(((((-1.0)*x432))+(((-1.0)*x433))+((x432*x433)))),-1);
if(!x435.valid){
continue;
}
CheckValue<IkReal> x436 = IKatan2WithCheck(IkReal((((new_r00*x434))+((cj1*new_r01)))),IkReal((((new_r01*x434))+(((-1.0)*cj1*new_r00)))),IKFAST_ATAN2_MAGTHRESH);
if(!x436.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x435.value)))+(x436.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[10];
IkReal x437=IKcos(j3);
IkReal x438=IKsin(j3);
IkReal x439=(cj1*new_r22);
IkReal x440=(new_r22*sj1);
IkReal x441=((1.0)*new_r01);
IkReal x442=((1.0)*new_r00);
IkReal x443=((1.0)*x437);
IkReal x444=(cj1*x438);
IkReal x445=((1.0)*x438);
evalcond[0]=(((new_r11*sj1))+((cj1*new_r01))+x438);
evalcond[1]=((((-1.0)*x443))+((new_r10*sj1))+((cj1*new_r00)));
evalcond[2]=(x444+new_r01+((x437*x440)));
evalcond[3]=((((-1.0)*cj1*x443))+((x438*x440))+new_r00);
evalcond[4]=((((-1.0)*x439*x443))+new_r11+((sj1*x438)));
evalcond[5]=(((cj1*new_r10))+(((-1.0)*sj1*x442))+(((-1.0)*new_r22*x445)));
evalcond[6]=(((cj1*new_r11))+(((-1.0)*sj1*x441))+(((-1.0)*new_r22*x443)));
evalcond[7]=((((-1.0)*x439*x445))+new_r10+(((-1.0)*sj1*x443)));
evalcond[8]=((((-1.0)*x445))+((new_r10*x439))+(((-1.0)*x440*x442)));
evalcond[9]=((((-1.0)*x443))+((new_r11*x439))+(((-1.0)*x440*x441)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x447=IKPowWithIntegerCheck(sj2,-1);
if(!x447.valid){
continue;
}
IkReal x446=x447.value;
CheckValue<IkReal> x448=IKPowWithIntegerCheck(new_r02,-1);
if(!x448.valid){
continue;
}
if( IKabs((x446*(x448.value)*(((1.0)+(((-1.0)*(cj2*cj2)))+(((-1.0)*(new_r12*new_r12))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r12*x446)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x446*(x448.value)*(((1.0)+(((-1.0)*(cj2*cj2)))+(((-1.0)*(new_r12*new_r12)))))))+IKsqr(((-1.0)*new_r12*x446))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((x446*(x448.value)*(((1.0)+(((-1.0)*(cj2*cj2)))+(((-1.0)*(new_r12*new_r12)))))), ((-1.0)*new_r12*x446));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x449=IKsin(j1);
IkReal x450=IKcos(j1);
IkReal x451=(sj2*x449);
IkReal x452=(new_r12*x450);
IkReal x453=((1.0)*sj2*x450);
IkReal x454=((1.0)*new_r02*x449);
evalcond[0]=(((sj2*x450))+new_r12);
evalcond[1]=((((-1.0)*x451))+new_r02);
evalcond[2]=(((new_r12*x449))+((new_r02*x450)));
evalcond[3]=(sj2+(((-1.0)*x454))+x452);
evalcond[4]=(((new_r22*sj2))+((cj2*x452))+(((-1.0)*cj2*x454)));
evalcond[5]=((((-1.0)*new_r10*x453))+((new_r00*x451))+((cj2*new_r20)));
evalcond[6]=(((new_r01*x451))+(((-1.0)*new_r11*x453))+((cj2*new_r21)));
evalcond[7]=((-1.0)+(((-1.0)*sj2*x452))+((new_r02*x451))+((cj2*new_r22)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[3];
j3eval[0]=sj2;
j3eval[1]=IKsign(sj2);
j3eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
j3eval[0]=sj2;
j3eval[1]=cj1;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
j3eval[0]=sj2;
j3eval[1]=cj2;
j3eval[2]=sj1;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x455=((1.0)*sj1);
if( IKabs(((((-1.0)*new_r00*x455))+(((-1.0)*cj1*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x455))+((cj1*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x455))+(((-1.0)*cj1*new_r01))))+IKsqr(((((-1.0)*new_r01*x455))+((cj1*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*new_r00*x455))+(((-1.0)*cj1*new_r01))), ((((-1.0)*new_r01*x455))+((cj1*new_r00))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x456=IKcos(j3);
IkReal x457=IKsin(j3);
IkReal x458=((1.0)*sj1);
IkReal x459=(sj1*x457);
IkReal x460=((1.0)*x456);
IkReal x461=((1.0)*x457);
IkReal x462=(sj1*x456);
IkReal x463=(cj1*x460);
evalcond[0]=(((new_r11*sj1))+((cj1*new_r01))+x457);
evalcond[1]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x460)));
evalcond[2]=(((cj1*x457))+x462+new_r01);
evalcond[3]=((((-1.0)*x463))+x459+new_r00);
evalcond[4]=((((-1.0)*x463))+x459+new_r11);
evalcond[5]=(((cj1*new_r10))+(((-1.0)*x461))+(((-1.0)*new_r00*x458)));
evalcond[6]=(((cj1*new_r11))+(((-1.0)*new_r01*x458))+(((-1.0)*x460)));
evalcond[7]=((((-1.0)*x456*x458))+(((-1.0)*cj1*x461))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x464=((1.0)*cj1);
if( IKabs(((((-1.0)*new_r01*x464))+(((-1.0)*new_r11*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r11*x464))+((new_r01*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r01*x464))+(((-1.0)*new_r11*sj1))))+IKsqr(((((-1.0)*new_r11*x464))+((new_r01*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*new_r01*x464))+(((-1.0)*new_r11*sj1))), ((((-1.0)*new_r11*x464))+((new_r01*sj1))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x465=IKsin(j3);
IkReal x466=IKcos(j3);
IkReal x467=((1.0)*sj1);
IkReal x468=(cj1*x465);
IkReal x469=(cj1*x466);
IkReal x470=(x466*x467);
evalcond[0]=(((new_r11*sj1))+((cj1*new_r01))+x465);
evalcond[1]=(((cj1*new_r10))+(((-1.0)*new_r00*x467))+x465);
evalcond[2]=(((cj1*new_r11))+(((-1.0)*new_r01*x467))+x466);
evalcond[3]=(((new_r10*sj1))+(((-1.0)*x466))+((cj1*new_r00)));
evalcond[4]=(x469+((sj1*x465))+new_r11);
evalcond[5]=((((-1.0)*x470))+x468+new_r01);
evalcond[6]=((((-1.0)*x470))+x468+new_r10);
evalcond[7]=((((-1.0)*x465*x467))+(((-1.0)*x469))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r20)+IKsqr(new_r21)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(new_r20, new_r21);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x471=IKsin(j3);
IkReal x472=IKcos(j3);
IkReal x473=((1.0)*x472);
evalcond[0]=((((-1.0)*x471))+new_r20);
evalcond[1]=((((-1.0)*x473))+new_r21);
evalcond[2]=(((cj1*x471))+new_r01);
evalcond[3]=(((sj1*x471))+new_r11);
evalcond[4]=((((-1.0)*cj1*x473))+new_r00);
evalcond[5]=((((-1.0)*sj1*x473))+new_r10);
evalcond[6]=(((new_r11*sj1))+((cj1*new_r01))+x471);
evalcond[7]=(((new_r10*sj1))+(((-1.0)*x473))+((cj1*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r20))+IKsqr(((-1.0)*new_r21))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-1.0)*new_r20), ((-1.0)*new_r21));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x474=IKsin(j3);
IkReal x475=IKcos(j3);
IkReal x476=((1.0)*x475);
evalcond[0]=(x474+new_r20);
evalcond[1]=(x475+new_r21);
evalcond[2]=(((cj1*x474))+new_r01);
evalcond[3]=(((sj1*x474))+new_r11);
evalcond[4]=((((-1.0)*cj1*x476))+new_r00);
evalcond[5]=((((-1.0)*sj1*x476))+new_r10);
evalcond[6]=(((new_r11*sj1))+((cj1*new_r01))+x474);
evalcond[7]=(((new_r10*sj1))+(((-1.0)*x476))+((cj1*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-1.0)*new_r01), new_r00);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x477=IKsin(j3);
IkReal x478=IKcos(j3);
IkReal x479=((1.0)*x478);
IkReal x480=((1.0)*x477);
evalcond[0]=(x477+new_r01);
evalcond[1]=((((-1.0)*x479))+new_r00);
evalcond[2]=((((-1.0)*sj2*x480))+new_r20);
evalcond[3]=((((-1.0)*sj2*x479))+new_r21);
evalcond[4]=(new_r11+(((-1.0)*cj2*x479)));
evalcond[5]=((((-1.0)*cj2*x480))+new_r10);
evalcond[6]=(((new_r20*sj2))+(((-1.0)*x480))+((cj2*new_r10)));
evalcond[7]=((((-1.0)*x479))+((cj2*new_r11))+((new_r21*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(new_r01, ((-1.0)*new_r00));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x481=IKsin(j3);
IkReal x482=IKcos(j3);
IkReal x483=((1.0)*cj2);
IkReal x484=((1.0)*x482);
IkReal x485=((1.0)*x481);
evalcond[0]=(x481+(((-1.0)*new_r01)));
evalcond[1]=(((cj2*x482))+new_r11);
evalcond[2]=((((-1.0)*sj2*x485))+new_r20);
evalcond[3]=((((-1.0)*sj2*x484))+new_r21);
evalcond[4]=((((-1.0)*x484))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x481*x483))+(((-1.0)*new_r10)));
evalcond[6]=((((-1.0)*new_r10*x483))+((new_r20*sj2))+(((-1.0)*x485)));
evalcond[7]=((((-1.0)*new_r11*x483))+(((-1.0)*x484))+((new_r21*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-1.0)*new_r11), new_r10);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x486=IKcos(j3);
IkReal x487=IKsin(j3);
IkReal x488=((1.0)*cj2);
IkReal x489=((1.0)*x486);
IkReal x490=((1.0)*x487);
evalcond[0]=(x487+new_r11);
evalcond[1]=((((-1.0)*x489))+new_r10);
evalcond[2]=(((cj2*x486))+new_r01);
evalcond[3]=(((cj2*x487))+new_r00);
evalcond[4]=((((-1.0)*sj2*x490))+new_r20);
evalcond[5]=((((-1.0)*sj2*x489))+new_r21);
evalcond[6]=((((-1.0)*x490))+((new_r20*sj2))+(((-1.0)*new_r00*x488)));
evalcond[7]=((((-1.0)*new_r01*x488))+(((-1.0)*x489))+((new_r21*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(new_r11, ((-1.0)*new_r10));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x491=IKsin(j3);
IkReal x492=IKcos(j3);
IkReal x493=((1.0)*x492);
IkReal x494=((1.0)*x491);
evalcond[0]=(x491+(((-1.0)*new_r11)));
evalcond[1]=((((-1.0)*sj2*x494))+new_r20);
evalcond[2]=((((-1.0)*sj2*x493))+new_r21);
evalcond[3]=((((-1.0)*cj2*x493))+new_r01);
evalcond[4]=((((-1.0)*cj2*x494))+new_r00);
evalcond[5]=((((-1.0)*x493))+(((-1.0)*new_r10)));
evalcond[6]=((((-1.0)*x494))+((new_r20*sj2))+((cj2*new_r00)));
evalcond[7]=((((-1.0)*x493))+((cj2*new_r01))+((new_r21*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j3eval[0]=IKabs(new_r22);
if( IKabs(j3eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j3]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=new_r22;
op[1]=0;
op[2]=((-1.0)*new_r22);
polyroots2(op,zeror,numroots);
IkReal j3array[2], cj3array[2], sj3array[2], tempj3array[1];
int numsolutions = 0;
for(int ij3 = 0; ij3 < numroots; ++ij3)
{
IkReal htj3 = zeror[ij3];
tempj3array[0]=((2.0)*(atan(htj3)));
for(int kj3 = 0; kj3 < 1; ++kj3)
{
j3array[numsolutions] = tempj3array[kj3];
if( j3array[numsolutions] > IKPI )
{
    j3array[numsolutions]-=IK2PI;
}
else if( j3array[numsolutions] < -IKPI )
{
    j3array[numsolutions]+=IK2PI;
}
sj3array[numsolutions] = IKsin(j3array[numsolutions]);
cj3array[numsolutions] = IKcos(j3array[numsolutions]);
numsolutions++;
}
}
bool j3valid[2]={true,true};
_nj3 = 2;
for(int ij3 = 0; ij3 < numsolutions; ++ij3)
    {
if( !j3valid[ij3] )
{
    continue;
}
    j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
htj3 = IKtan(j3/2);

_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < numsolutions; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x496=IKPowWithIntegerCheck(sj2,-1);
if(!x496.valid){
continue;
}
IkReal x495=x496.value;
CheckValue<IkReal> x497=IKPowWithIntegerCheck(cj2,-1);
if(!x497.valid){
continue;
}
CheckValue<IkReal> x498=IKPowWithIntegerCheck(sj1,-1);
if(!x498.valid){
continue;
}
if( IKabs((new_r20*x495)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x495*(x497.value)*(x498.value)*(((((-1.0)*new_r01*sj2))+(((-1.0)*cj1*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r20*x495))+IKsqr((x495*(x497.value)*(x498.value)*(((((-1.0)*new_r01*sj2))+(((-1.0)*cj1*new_r20))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((new_r20*x495), (x495*(x497.value)*(x498.value)*(((((-1.0)*new_r01*sj2))+(((-1.0)*cj1*new_r20))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x499=IKsin(j3);
IkReal x500=IKcos(j3);
IkReal x501=(cj2*sj1);
IkReal x502=(cj1*new_r11);
IkReal x503=((1.0)*new_r01);
IkReal x504=(cj1*cj2);
IkReal x505=((1.0)*new_r00);
IkReal x506=((1.0)*x500);
IkReal x507=(cj1*x499);
IkReal x508=((1.0)*x499);
evalcond[0]=((((-1.0)*sj2*x508))+new_r20);
evalcond[1]=((((-1.0)*sj2*x506))+new_r21);
evalcond[2]=(((new_r11*sj1))+((cj1*new_r01))+x499);
evalcond[3]=(((new_r10*sj1))+(((-1.0)*x506))+((cj1*new_r00)));
evalcond[4]=(((x500*x501))+x507+new_r01);
evalcond[5]=(new_r00+((x499*x501))+(((-1.0)*cj1*x506)));
evalcond[6]=(((sj1*x499))+(((-1.0)*x504*x506))+new_r11);
evalcond[7]=((((-1.0)*sj1*x505))+((cj1*new_r10))+(((-1.0)*cj2*x508)));
evalcond[8]=((((-1.0)*sj1*x503))+x502+(((-1.0)*cj2*x506)));
evalcond[9]=((((-1.0)*sj1*x506))+(((-1.0)*x504*x508))+new_r10);
evalcond[10]=(((new_r20*sj2))+(((-1.0)*x508))+(((-1.0)*x501*x505))+((new_r10*x504)));
evalcond[11]=(((cj2*x502))+(((-1.0)*x506))+(((-1.0)*x501*x503))+((new_r21*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x510=IKPowWithIntegerCheck(sj2,-1);
if(!x510.valid){
continue;
}
IkReal x509=x510.value;
CheckValue<IkReal> x511=IKPowWithIntegerCheck(cj1,-1);
if(!x511.valid){
continue;
}
if( IKabs((new_r20*x509)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x509*(x511.value)*((((new_r00*sj2))+((cj2*new_r20*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r20*x509))+IKsqr((x509*(x511.value)*((((new_r00*sj2))+((cj2*new_r20*sj1))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((new_r20*x509), (x509*(x511.value)*((((new_r00*sj2))+((cj2*new_r20*sj1))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x512=IKsin(j3);
IkReal x513=IKcos(j3);
IkReal x514=(cj2*sj1);
IkReal x515=(cj1*new_r11);
IkReal x516=((1.0)*new_r01);
IkReal x517=(cj1*cj2);
IkReal x518=((1.0)*new_r00);
IkReal x519=((1.0)*x513);
IkReal x520=(cj1*x512);
IkReal x521=((1.0)*x512);
evalcond[0]=((((-1.0)*sj2*x521))+new_r20);
evalcond[1]=((((-1.0)*sj2*x519))+new_r21);
evalcond[2]=(((new_r11*sj1))+((cj1*new_r01))+x512);
evalcond[3]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x519)));
evalcond[4]=(((x513*x514))+x520+new_r01);
evalcond[5]=((((-1.0)*cj1*x519))+((x512*x514))+new_r00);
evalcond[6]=((((-1.0)*x517*x519))+new_r11+((sj1*x512)));
evalcond[7]=((((-1.0)*cj2*x521))+((cj1*new_r10))+(((-1.0)*sj1*x518)));
evalcond[8]=((((-1.0)*cj2*x519))+(((-1.0)*sj1*x516))+x515);
evalcond[9]=((((-1.0)*sj1*x519))+(((-1.0)*x517*x521))+new_r10);
evalcond[10]=(((new_r10*x517))+((new_r20*sj2))+(((-1.0)*x514*x518))+(((-1.0)*x521)));
evalcond[11]=((((-1.0)*x514*x516))+((cj2*x515))+((new_r21*sj2))+(((-1.0)*x519)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x522=IKPowWithIntegerCheck(IKsign(sj2),-1);
if(!x522.valid){
continue;
}
CheckValue<IkReal> x523 = IKatan2WithCheck(IkReal(new_r20),IkReal(new_r21),IKFAST_ATAN2_MAGTHRESH);
if(!x523.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x522.value)))+(x523.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x524=IKsin(j3);
IkReal x525=IKcos(j3);
IkReal x526=(cj2*sj1);
IkReal x527=(cj1*new_r11);
IkReal x528=((1.0)*new_r01);
IkReal x529=(cj1*cj2);
IkReal x530=((1.0)*new_r00);
IkReal x531=((1.0)*x525);
IkReal x532=(cj1*x524);
IkReal x533=((1.0)*x524);
evalcond[0]=((((-1.0)*sj2*x533))+new_r20);
evalcond[1]=((((-1.0)*sj2*x531))+new_r21);
evalcond[2]=(((new_r11*sj1))+((cj1*new_r01))+x524);
evalcond[3]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x531)));
evalcond[4]=(((x525*x526))+x532+new_r01);
evalcond[5]=((((-1.0)*cj1*x531))+((x524*x526))+new_r00);
evalcond[6]=(((sj1*x524))+(((-1.0)*x529*x531))+new_r11);
evalcond[7]=((((-1.0)*cj2*x533))+(((-1.0)*sj1*x530))+((cj1*new_r10)));
evalcond[8]=((((-1.0)*sj1*x528))+(((-1.0)*cj2*x531))+x527);
evalcond[9]=((((-1.0)*sj1*x531))+(((-1.0)*x529*x533))+new_r10);
evalcond[10]=((((-1.0)*x526*x530))+((new_r20*sj2))+(((-1.0)*x533))+((new_r10*x529)));
evalcond[11]=((((-1.0)*x526*x528))+(((-1.0)*x531))+((cj2*x527))+((new_r21*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x534=IKPowWithIntegerCheck(IKsign(sj2),-1);
if(!x534.valid){
continue;
}
CheckValue<IkReal> x535 = IKatan2WithCheck(IkReal(new_r02),IkReal(((-1.0)*new_r12)),IKFAST_ATAN2_MAGTHRESH);
if(!x535.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x534.value)))+(x535.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x536=IKsin(j1);
IkReal x537=IKcos(j1);
IkReal x538=(sj2*x536);
IkReal x539=(new_r12*x537);
IkReal x540=((1.0)*sj2*x537);
IkReal x541=((1.0)*new_r02*x536);
evalcond[0]=(((sj2*x537))+new_r12);
evalcond[1]=((((-1.0)*x538))+new_r02);
evalcond[2]=(((new_r02*x537))+((new_r12*x536)));
evalcond[3]=(sj2+(((-1.0)*x541))+x539);
evalcond[4]=((((-1.0)*cj2*x541))+((new_r22*sj2))+((cj2*x539)));
evalcond[5]=((((-1.0)*new_r10*x540))+((cj2*new_r20))+((new_r00*x538)));
evalcond[6]=(((new_r01*x538))+(((-1.0)*new_r11*x540))+((cj2*new_r21)));
evalcond[7]=((-1.0)+((new_r02*x538))+(((-1.0)*sj2*x539))+((cj2*new_r22)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[3];
j3eval[0]=sj2;
j3eval[1]=IKsign(sj2);
j3eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
j3eval[0]=sj2;
j3eval[1]=cj1;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
j3eval[0]=sj2;
j3eval[1]=cj2;
j3eval[2]=sj1;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x542=((1.0)*sj1);
if( IKabs(((((-1.0)*new_r00*x542))+(((-1.0)*cj1*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*new_r00))+(((-1.0)*new_r01*x542)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x542))+(((-1.0)*cj1*new_r01))))+IKsqr((((cj1*new_r00))+(((-1.0)*new_r01*x542))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*new_r00*x542))+(((-1.0)*cj1*new_r01))), (((cj1*new_r00))+(((-1.0)*new_r01*x542))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x543=IKcos(j3);
IkReal x544=IKsin(j3);
IkReal x545=((1.0)*sj1);
IkReal x546=(sj1*x544);
IkReal x547=((1.0)*x543);
IkReal x548=((1.0)*x544);
IkReal x549=(sj1*x543);
IkReal x550=(cj1*x547);
evalcond[0]=(((new_r11*sj1))+((cj1*new_r01))+x544);
evalcond[1]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x547)));
evalcond[2]=(((cj1*x544))+x549+new_r01);
evalcond[3]=((((-1.0)*x550))+x546+new_r00);
evalcond[4]=((((-1.0)*x550))+x546+new_r11);
evalcond[5]=((((-1.0)*new_r00*x545))+((cj1*new_r10))+(((-1.0)*x548)));
evalcond[6]=(((cj1*new_r11))+(((-1.0)*new_r01*x545))+(((-1.0)*x547)));
evalcond[7]=((((-1.0)*cj1*x548))+new_r10+(((-1.0)*x543*x545)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x551=((1.0)*cj1);
if( IKabs(((((-1.0)*new_r01*x551))+(((-1.0)*new_r11*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*sj1))+(((-1.0)*new_r11*x551)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r01*x551))+(((-1.0)*new_r11*sj1))))+IKsqr((((new_r01*sj1))+(((-1.0)*new_r11*x551))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*new_r01*x551))+(((-1.0)*new_r11*sj1))), (((new_r01*sj1))+(((-1.0)*new_r11*x551))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x552=IKsin(j3);
IkReal x553=IKcos(j3);
IkReal x554=((1.0)*sj1);
IkReal x555=(cj1*x552);
IkReal x556=(cj1*x553);
IkReal x557=(x553*x554);
evalcond[0]=(((new_r11*sj1))+((cj1*new_r01))+x552);
evalcond[1]=(((cj1*new_r10))+(((-1.0)*new_r00*x554))+x552);
evalcond[2]=(((cj1*new_r11))+(((-1.0)*new_r01*x554))+x553);
evalcond[3]=((((-1.0)*x553))+((new_r10*sj1))+((cj1*new_r00)));
evalcond[4]=(((sj1*x552))+x556+new_r11);
evalcond[5]=((((-1.0)*x557))+x555+new_r01);
evalcond[6]=((((-1.0)*x557))+x555+new_r10);
evalcond[7]=((((-1.0)*x556))+(((-1.0)*x552*x554))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r20)+IKsqr(new_r21)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(new_r20, new_r21);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x558=IKsin(j3);
IkReal x559=IKcos(j3);
IkReal x560=((1.0)*x559);
evalcond[0]=((((-1.0)*x558))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x560)));
evalcond[2]=(((cj1*x558))+new_r01);
evalcond[3]=(((sj1*x558))+new_r11);
evalcond[4]=((((-1.0)*cj1*x560))+new_r00);
evalcond[5]=((((-1.0)*sj1*x560))+new_r10);
evalcond[6]=(((new_r11*sj1))+((cj1*new_r01))+x558);
evalcond[7]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x560)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r20))+IKsqr(((-1.0)*new_r21))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-1.0)*new_r20), ((-1.0)*new_r21));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x561=IKsin(j3);
IkReal x562=IKcos(j3);
IkReal x563=((1.0)*x562);
evalcond[0]=(x561+new_r20);
evalcond[1]=(x562+new_r21);
evalcond[2]=(((cj1*x561))+new_r01);
evalcond[3]=(((sj1*x561))+new_r11);
evalcond[4]=((((-1.0)*cj1*x563))+new_r00);
evalcond[5]=((((-1.0)*sj1*x563))+new_r10);
evalcond[6]=(((new_r11*sj1))+((cj1*new_r01))+x561);
evalcond[7]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x563)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-1.0)*new_r01), new_r00);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x564=IKsin(j3);
IkReal x565=IKcos(j3);
IkReal x566=((1.0)*x565);
IkReal x567=((1.0)*x564);
evalcond[0]=(x564+new_r01);
evalcond[1]=(new_r00+(((-1.0)*x566)));
evalcond[2]=(new_r20+(((-1.0)*sj2*x567)));
evalcond[3]=(new_r21+(((-1.0)*sj2*x566)));
evalcond[4]=(new_r11+(((-1.0)*cj2*x566)));
evalcond[5]=(new_r10+(((-1.0)*cj2*x567)));
evalcond[6]=(((new_r20*sj2))+((cj2*new_r10))+(((-1.0)*x567)));
evalcond[7]=(((cj2*new_r11))+((new_r21*sj2))+(((-1.0)*x566)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(new_r01, ((-1.0)*new_r00));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x568=IKsin(j3);
IkReal x569=IKcos(j3);
IkReal x570=((1.0)*cj2);
IkReal x571=((1.0)*x569);
IkReal x572=((1.0)*x568);
evalcond[0]=(x568+(((-1.0)*new_r01)));
evalcond[1]=(((cj2*x569))+new_r11);
evalcond[2]=((((-1.0)*sj2*x572))+new_r20);
evalcond[3]=((((-1.0)*sj2*x571))+new_r21);
evalcond[4]=((((-1.0)*x571))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*new_r10))+(((-1.0)*x568*x570)));
evalcond[6]=(((new_r20*sj2))+(((-1.0)*new_r10*x570))+(((-1.0)*x572)));
evalcond[7]=((((-1.0)*new_r11*x570))+(((-1.0)*x571))+((new_r21*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-1.0)*new_r11), new_r10);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x573=IKcos(j3);
IkReal x574=IKsin(j3);
IkReal x575=((1.0)*cj2);
IkReal x576=((1.0)*x573);
IkReal x577=((1.0)*x574);
evalcond[0]=(x574+new_r11);
evalcond[1]=((((-1.0)*x576))+new_r10);
evalcond[2]=(((cj2*x573))+new_r01);
evalcond[3]=(((cj2*x574))+new_r00);
evalcond[4]=((((-1.0)*sj2*x577))+new_r20);
evalcond[5]=((((-1.0)*sj2*x576))+new_r21);
evalcond[6]=(((new_r20*sj2))+(((-1.0)*x577))+(((-1.0)*new_r00*x575)));
evalcond[7]=((((-1.0)*x576))+(((-1.0)*new_r01*x575))+((new_r21*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(new_r11, ((-1.0)*new_r10));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x578=IKsin(j3);
IkReal x579=IKcos(j3);
IkReal x580=((1.0)*x579);
IkReal x581=((1.0)*x578);
evalcond[0]=(x578+(((-1.0)*new_r11)));
evalcond[1]=((((-1.0)*sj2*x581))+new_r20);
evalcond[2]=((((-1.0)*sj2*x580))+new_r21);
evalcond[3]=(new_r01+(((-1.0)*cj2*x580)));
evalcond[4]=(new_r00+(((-1.0)*cj2*x581)));
evalcond[5]=((((-1.0)*new_r10))+(((-1.0)*x580)));
evalcond[6]=(((new_r20*sj2))+((cj2*new_r00))+(((-1.0)*x581)));
evalcond[7]=(((cj2*new_r01))+((new_r21*sj2))+(((-1.0)*x580)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j3eval[0]=IKabs(new_r22);
if( IKabs(j3eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j3]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=new_r22;
op[1]=0;
op[2]=((-1.0)*new_r22);
polyroots2(op,zeror,numroots);
IkReal j3array[2], cj3array[2], sj3array[2], tempj3array[1];
int numsolutions = 0;
for(int ij3 = 0; ij3 < numroots; ++ij3)
{
IkReal htj3 = zeror[ij3];
tempj3array[0]=((2.0)*(atan(htj3)));
for(int kj3 = 0; kj3 < 1; ++kj3)
{
j3array[numsolutions] = tempj3array[kj3];
if( j3array[numsolutions] > IKPI )
{
    j3array[numsolutions]-=IK2PI;
}
else if( j3array[numsolutions] < -IKPI )
{
    j3array[numsolutions]+=IK2PI;
}
sj3array[numsolutions] = IKsin(j3array[numsolutions]);
cj3array[numsolutions] = IKcos(j3array[numsolutions]);
numsolutions++;
}
}
bool j3valid[2]={true,true};
_nj3 = 2;
for(int ij3 = 0; ij3 < numsolutions; ++ij3)
    {
if( !j3valid[ij3] )
{
    continue;
}
    j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
htj3 = IKtan(j3/2);

_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < numsolutions; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x583=IKPowWithIntegerCheck(sj2,-1);
if(!x583.valid){
continue;
}
IkReal x582=x583.value;
CheckValue<IkReal> x584=IKPowWithIntegerCheck(cj2,-1);
if(!x584.valid){
continue;
}
CheckValue<IkReal> x585=IKPowWithIntegerCheck(sj1,-1);
if(!x585.valid){
continue;
}
if( IKabs((new_r20*x582)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x582*(x584.value)*(x585.value)*(((((-1.0)*new_r01*sj2))+(((-1.0)*cj1*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r20*x582))+IKsqr((x582*(x584.value)*(x585.value)*(((((-1.0)*new_r01*sj2))+(((-1.0)*cj1*new_r20))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((new_r20*x582), (x582*(x584.value)*(x585.value)*(((((-1.0)*new_r01*sj2))+(((-1.0)*cj1*new_r20))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x586=IKsin(j3);
IkReal x587=IKcos(j3);
IkReal x588=(cj2*sj1);
IkReal x589=(cj1*new_r11);
IkReal x590=((1.0)*new_r01);
IkReal x591=(cj1*cj2);
IkReal x592=((1.0)*new_r00);
IkReal x593=((1.0)*x587);
IkReal x594=(cj1*x586);
IkReal x595=((1.0)*x586);
evalcond[0]=((((-1.0)*sj2*x595))+new_r20);
evalcond[1]=((((-1.0)*sj2*x593))+new_r21);
evalcond[2]=(((new_r11*sj1))+((cj1*new_r01))+x586);
evalcond[3]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x593)));
evalcond[4]=(((x587*x588))+x594+new_r01);
evalcond[5]=(((x586*x588))+(((-1.0)*cj1*x593))+new_r00);
evalcond[6]=(((sj1*x586))+new_r11+(((-1.0)*x591*x593)));
evalcond[7]=(((cj1*new_r10))+(((-1.0)*sj1*x592))+(((-1.0)*cj2*x595)));
evalcond[8]=((((-1.0)*sj1*x590))+(((-1.0)*cj2*x593))+x589);
evalcond[9]=((((-1.0)*sj1*x593))+new_r10+(((-1.0)*x591*x595)));
evalcond[10]=((((-1.0)*x588*x592))+((new_r20*sj2))+((new_r10*x591))+(((-1.0)*x595)));
evalcond[11]=((((-1.0)*x588*x590))+(((-1.0)*x593))+((new_r21*sj2))+((cj2*x589)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x597=IKPowWithIntegerCheck(sj2,-1);
if(!x597.valid){
continue;
}
IkReal x596=x597.value;
CheckValue<IkReal> x598=IKPowWithIntegerCheck(cj1,-1);
if(!x598.valid){
continue;
}
if( IKabs((new_r20*x596)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x596*(x598.value)*((((new_r00*sj2))+((cj2*new_r20*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r20*x596))+IKsqr((x596*(x598.value)*((((new_r00*sj2))+((cj2*new_r20*sj1))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((new_r20*x596), (x596*(x598.value)*((((new_r00*sj2))+((cj2*new_r20*sj1))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x599=IKsin(j3);
IkReal x600=IKcos(j3);
IkReal x601=(cj2*sj1);
IkReal x602=(cj1*new_r11);
IkReal x603=((1.0)*new_r01);
IkReal x604=(cj1*cj2);
IkReal x605=((1.0)*new_r00);
IkReal x606=((1.0)*x600);
IkReal x607=(cj1*x599);
IkReal x608=((1.0)*x599);
evalcond[0]=((((-1.0)*sj2*x608))+new_r20);
evalcond[1]=((((-1.0)*sj2*x606))+new_r21);
evalcond[2]=(((new_r11*sj1))+((cj1*new_r01))+x599);
evalcond[3]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x606)));
evalcond[4]=(((x600*x601))+x607+new_r01);
evalcond[5]=((((-1.0)*cj1*x606))+((x599*x601))+new_r00);
evalcond[6]=((((-1.0)*x604*x606))+((sj1*x599))+new_r11);
evalcond[7]=((((-1.0)*cj2*x608))+((cj1*new_r10))+(((-1.0)*sj1*x605)));
evalcond[8]=((((-1.0)*cj2*x606))+(((-1.0)*sj1*x603))+x602);
evalcond[9]=((((-1.0)*x604*x608))+(((-1.0)*sj1*x606))+new_r10);
evalcond[10]=(((new_r20*sj2))+((new_r10*x604))+(((-1.0)*x608))+(((-1.0)*x601*x605)));
evalcond[11]=(((cj2*x602))+(((-1.0)*x606))+((new_r21*sj2))+(((-1.0)*x601*x603)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x609=IKPowWithIntegerCheck(IKsign(sj2),-1);
if(!x609.valid){
continue;
}
CheckValue<IkReal> x610 = IKatan2WithCheck(IkReal(new_r20),IkReal(new_r21),IKFAST_ATAN2_MAGTHRESH);
if(!x610.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x609.value)))+(x610.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x611=IKsin(j3);
IkReal x612=IKcos(j3);
IkReal x613=(cj2*sj1);
IkReal x614=(cj1*new_r11);
IkReal x615=((1.0)*new_r01);
IkReal x616=(cj1*cj2);
IkReal x617=((1.0)*new_r00);
IkReal x618=((1.0)*x612);
IkReal x619=(cj1*x611);
IkReal x620=((1.0)*x611);
evalcond[0]=(new_r20+(((-1.0)*sj2*x620)));
evalcond[1]=((((-1.0)*sj2*x618))+new_r21);
evalcond[2]=(((new_r11*sj1))+((cj1*new_r01))+x611);
evalcond[3]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x618)));
evalcond[4]=(((x612*x613))+x619+new_r01);
evalcond[5]=((((-1.0)*cj1*x618))+((x611*x613))+new_r00);
evalcond[6]=(((sj1*x611))+new_r11+(((-1.0)*x616*x618)));
evalcond[7]=((((-1.0)*sj1*x617))+((cj1*new_r10))+(((-1.0)*cj2*x620)));
evalcond[8]=((((-1.0)*cj2*x618))+(((-1.0)*sj1*x615))+x614);
evalcond[9]=((((-1.0)*sj1*x618))+new_r10+(((-1.0)*x616*x620)));
evalcond[10]=(((new_r20*sj2))+(((-1.0)*x620))+((new_r10*x616))+(((-1.0)*x613*x617)));
evalcond[11]=(((cj2*x614))+(((-1.0)*x618))+(((-1.0)*x613*x615))+((new_r21*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x621=IKPowWithIntegerCheck(IKsign(sj2),-1);
if(!x621.valid){
continue;
}
CheckValue<IkReal> x622 = IKatan2WithCheck(IkReal(new_r20),IkReal(new_r21),IKFAST_ATAN2_MAGTHRESH);
if(!x622.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x621.value)))+(x622.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[2];
IkReal x623=((1.0)*sj2);
evalcond[0]=((((-1.0)*x623*(IKsin(j3))))+new_r20);
evalcond[1]=((((-1.0)*x623*(IKcos(j3))))+new_r21);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[3];
j1eval[0]=sj2;
j1eval[1]=IKsign(sj2);
j1eval[2]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
j1eval[0]=new_r11;
j1eval[1]=sj2;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x624=((1.0)*new_r01);
if( IKabs(((((-1.0)*new_r00*sj3))+(((-1.0)*cj3*x624)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj3*new_r00))+(((-1.0)*sj3*x624)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*sj3))+(((-1.0)*cj3*x624))))+IKsqr((((cj3*new_r00))+(((-1.0)*sj3*x624))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((-1.0)*new_r00*sj3))+(((-1.0)*cj3*x624))), (((cj3*new_r00))+(((-1.0)*sj3*x624))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x625=IKsin(j1);
IkReal x626=IKcos(j1);
IkReal x627=((1.0)*cj3);
IkReal x628=((1.0)*sj3);
IkReal x629=(sj3*x625);
IkReal x630=((1.0)*x625);
IkReal x631=(x626*x627);
evalcond[0]=(sj3+((new_r01*x626))+((new_r11*x625)));
evalcond[1]=(((cj3*x625))+((sj3*x626))+new_r01);
evalcond[2]=((((-1.0)*x631))+x629+new_r00);
evalcond[3]=((((-1.0)*x631))+x629+new_r11);
evalcond[4]=((((-1.0)*x627))+((new_r00*x626))+((new_r10*x625)));
evalcond[5]=((((-1.0)*x625*x627))+(((-1.0)*x626*x628))+new_r10);
evalcond[6]=((((-1.0)*new_r00*x630))+(((-1.0)*x628))+((new_r10*x626)));
evalcond[7]=((((-1.0)*new_r01*x630))+(((-1.0)*x627))+((new_r11*x626)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
IkReal x632=(((new_r11*sj3))+((cj3*new_r01)));
j1eval[0]=x632;
j1eval[1]=((IKabs(((-1.0)+(cj3*cj3)+(new_r01*new_r01))))+(IKabs(((((-1.0)*cj3*sj3))+(((-1.0)*new_r01*new_r11))))));
j1eval[2]=IKsign(x632);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
IkReal x633=((1.0)*sj3);
IkReal x634=(((new_r10*new_r11))+((new_r00*new_r01)));
j1eval[0]=x634;
j1eval[1]=IKsign(x634);
j1eval[2]=((IKabs((((new_r01*sj3))+(((-1.0)*new_r10*x633)))))+(IKabs(((((-1.0)*new_r00*x633))+(((-1.0)*new_r11*x633))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
IkReal x635=((1.0)*sj3);
IkReal x636=((new_r01*new_r01)+(new_r11*new_r11));
j1eval[0]=x636;
j1eval[1]=((IKabs((((cj3*new_r01))+(((-1.0)*new_r11*x635)))))+(IKabs(((((-1.0)*new_r01*x635))+(((-1.0)*cj3*new_r11))))));
j1eval[2]=IKsign(x636);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((new_r01*new_r01)+(new_r11*new_r11));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
new_r01=0;
new_r11=0;
j1eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x638 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x638.valid){
continue;
}
IkReal x637=x638.value;
j1array[0]=((-1.0)*x637);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x637)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r00*(IKsin(j1))))+((new_r10*(IKcos(j1)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x639=IKcos(j1);
IkReal x640=IKsin(j1);
IkReal x641=((1.0)*x640);
evalcond[0]=(x639+new_r11);
evalcond[1]=((((-1.0)*x641))+new_r01);
evalcond[2]=((((-1.0)*x639))+new_r00);
evalcond[3]=((((-1.0)*x641))+new_r10);
evalcond[4]=(((new_r01*x639))+((new_r11*x640)));
evalcond[5]=((-1.0)+((new_r00*x639))+((new_r10*x640)));
evalcond[6]=((((-1.0)*new_r00*x641))+((new_r10*x639)));
evalcond[7]=((1.0)+(((-1.0)*new_r01*x641))+((new_r11*x639)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((-1.0)*new_r01), ((-1.0)*new_r00));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x642=IKsin(j1);
IkReal x643=IKcos(j1);
IkReal x644=((1.0)*x642);
evalcond[0]=(x642+new_r01);
evalcond[1]=(x643+new_r00);
evalcond[2]=(x642+new_r10);
evalcond[3]=((((-1.0)*x643))+new_r11);
evalcond[4]=(((new_r11*x642))+((new_r01*x643)));
evalcond[5]=((1.0)+((new_r10*x642))+((new_r00*x643)));
evalcond[6]=(((new_r10*x643))+(((-1.0)*new_r00*x644)));
evalcond[7]=((-1.0)+((new_r11*x643))+(((-1.0)*new_r01*x644)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x646 = ((new_r01*new_r01)+(new_r11*new_r11));
if(IKabs(x646)==0){
continue;
}
IkReal x645=pow(x646,-0.5);
CheckValue<IkReal> x647 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x647.valid){
continue;
}
IkReal gconst40=((-1.0)*(x647.value));
IkReal gconst41=((-1.0)*new_r01*x645);
IkReal gconst42=(new_r11*x645);
CheckValue<IkReal> x648 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x648.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x648.value)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
CheckValue<IkReal> x651 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x651.valid){
continue;
}
IkReal x649=((-1.0)*(x651.value));
IkReal x650=x645;
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=gconst41;
cj3=gconst42;
j3=x649;
IkReal gconst40=x649;
IkReal gconst41=((-1.0)*new_r01*x650);
IkReal gconst42=(new_r11*x650);
IkReal x652=new_r01*new_r01;
IkReal x653=(new_r00*new_r01);
IkReal x654=(((new_r10*new_r11))+x653);
IkReal x655=x645;
IkReal x656=(new_r01*x655);
j1eval[0]=x654;
j1eval[1]=IKsign(x654);
j1eval[2]=((IKabs((((x653*x655))+((new_r11*x656)))))+(IKabs((((new_r10*x656))+(((-1.0)*x652*x655))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
CheckValue<IkReal> x659 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x659.valid){
continue;
}
IkReal x657=((-1.0)*(x659.value));
IkReal x658=x645;
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=gconst41;
cj3=gconst42;
j3=x657;
IkReal gconst40=x657;
IkReal gconst41=((-1.0)*new_r01*x658);
IkReal gconst42=(new_r11*x658);
IkReal x660=((new_r01*new_r01)+(new_r11*new_r11));
j1eval[0]=x660;
j1eval[1]=IKsign(x660);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x663 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x663.valid){
continue;
}
IkReal x661=((-1.0)*(x663.value));
IkReal x662=x645;
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=gconst41;
cj3=gconst42;
j3=x661;
IkReal gconst40=x661;
IkReal gconst41=((-1.0)*new_r01*x662);
IkReal gconst42=(new_r11*x662);
j1eval[0]=((new_r01*new_r01)+(new_r11*new_r11));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((gconst42*gconst42)+(gconst41*gconst41));
evalcond[1]=new_r01;
evalcond[2]=new_r00;
evalcond[3]=new_r11;
evalcond[4]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
CheckValue<IkReal> x665 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x665.valid){
continue;
}
IkReal x664=((-1.0)*(x665.value));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=gconst41;
cj3=gconst42;
j3=x664;
new_r11=0;
new_r00=0;
IkReal gconst40=x664;
IkReal x666 = new_r01*new_r01;
if(IKabs(x666)==0){
continue;
}
IkReal gconst41=((-1.0)*new_r01*(pow(x666,-0.5)));
IkReal gconst42=0;
j1eval[0]=new_r01;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x667=IKPowWithIntegerCheck(gconst41,-1);
if(!x667.valid){
continue;
}
cj1array[0]=((-1.0)*new_r01*(x667.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x668=IKsin(j1);
IkReal x669=IKcos(j1);
IkReal x670=((-1.0)*x668);
evalcond[0]=(new_r10*x668);
evalcond[1]=(gconst41*x670);
evalcond[2]=(new_r01*x670);
evalcond[3]=(gconst41+((new_r01*x669)));
evalcond[4]=(gconst41+((new_r10*x669)));
evalcond[5]=(((gconst41*x669))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x671=IKPowWithIntegerCheck(new_r01,-1);
if(!x671.valid){
continue;
}
cj1array[0]=((-1.0)*gconst41*(x671.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x672=IKsin(j1);
IkReal x673=IKcos(j1);
IkReal x674=(gconst41*x673);
IkReal x675=((-1.0)*x672);
evalcond[0]=(new_r10*x672);
evalcond[1]=(gconst41*x675);
evalcond[2]=(new_r01*x675);
evalcond[3]=(x674+new_r01);
evalcond[4]=(((new_r10*x673))+gconst41);
evalcond[5]=(x674+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
evalcond[1]=gconst41;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
CheckValue<IkReal> x677 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x677.valid){
continue;
}
IkReal x676=((-1.0)*(x677.value));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=gconst41;
cj3=gconst42;
j3=x676;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst40=x676;
IkReal gconst41=((-1.0)*new_r01);
IkReal gconst42=new_r11;
j1eval[0]=-1.0;
j1eval[1]=((IKabs(new_r01*new_r01))+(IKabs((new_r01*new_r11))));
j1eval[2]=-1.0;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
CheckValue<IkReal> x679 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x679.valid){
continue;
}
IkReal x678=((-1.0)*(x679.value));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=gconst41;
cj3=gconst42;
j3=x678;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst40=x678;
IkReal gconst41=((-1.0)*new_r01);
IkReal gconst42=new_r11;
j1eval[0]=-1.0;
j1eval[1]=((IKabs((new_r01*new_r11)))+(IKabs(((1.0)+(((-1.0)*(new_r01*new_r01)))))));
j1eval[2]=-1.0;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
CheckValue<IkReal> x681 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x681.valid){
continue;
}
IkReal x680=((-1.0)*(x681.value));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=gconst41;
cj3=gconst42;
j3=x680;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst40=x680;
IkReal gconst41=((-1.0)*new_r01);
IkReal gconst42=new_r11;
j1eval[0]=1.0;
j1eval[1]=((((0.5)*(IKabs(((-1.0)+(((2.0)*(new_r01*new_r01))))))))+(IKabs((new_r01*new_r11))));
j1eval[2]=1.0;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x682=((1.0)*gconst41);
CheckValue<IkReal> x683 = IKatan2WithCheck(IkReal((((gconst42*new_r01))+(((-1.0)*new_r11*x682)))),IkReal(((((-1.0)*new_r01*x682))+(((-1.0)*gconst42*new_r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x683.valid){
continue;
}
CheckValue<IkReal> x684=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x684.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x683.value)+(((1.5707963267949)*(x684.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x685=IKcos(j1);
IkReal x686=IKsin(j1);
IkReal x687=((1.0)*gconst42);
IkReal x688=(gconst41*x685);
IkReal x689=(gconst41*x686);
IkReal x690=(x686*x687);
evalcond[0]=(gconst41+((new_r01*x685))+((new_r11*x686)));
evalcond[1]=(((gconst42*x685))+x689+new_r11);
evalcond[2]=(x688+(((-1.0)*x690)));
evalcond[3]=(x688+(((-1.0)*x690))+new_r01);
evalcond[4]=((((-1.0)*x685*x687))+(((-1.0)*x689)));
evalcond[5]=((((-1.0)*new_r01*x686))+gconst42+((new_r11*x685)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x691=IKPowWithIntegerCheck(IKsign(((((-1.0)*(gconst41*gconst41)))+(((-1.0)*(gconst42*gconst42))))),-1);
if(!x691.valid){
continue;
}
CheckValue<IkReal> x692 = IKatan2WithCheck(IkReal((gconst41*new_r11)),IkReal((gconst42*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x692.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x691.value)))+(x692.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x693=IKcos(j1);
IkReal x694=IKsin(j1);
IkReal x695=((1.0)*gconst42);
IkReal x696=(gconst41*x693);
IkReal x697=(gconst41*x694);
IkReal x698=(x694*x695);
evalcond[0]=(gconst41+((new_r11*x694))+((new_r01*x693)));
evalcond[1]=(((gconst42*x693))+x697+new_r11);
evalcond[2]=(x696+(((-1.0)*x698)));
evalcond[3]=(x696+(((-1.0)*x698))+new_r01);
evalcond[4]=((((-1.0)*x693*x695))+(((-1.0)*x697)));
evalcond[5]=(gconst42+((new_r11*x693))+(((-1.0)*new_r01*x694)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x699 = IKatan2WithCheck(IkReal((gconst41*gconst42)),IkReal(((-1.0)*(gconst41*gconst41))),IKFAST_ATAN2_MAGTHRESH);
if(!x699.valid){
continue;
}
CheckValue<IkReal> x700=IKPowWithIntegerCheck(IKsign((((gconst41*new_r01))+(((-1.0)*gconst42*new_r11)))),-1);
if(!x700.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x699.value)+(((1.5707963267949)*(x700.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x701=IKcos(j1);
IkReal x702=IKsin(j1);
IkReal x703=((1.0)*gconst42);
IkReal x704=(gconst41*x701);
IkReal x705=(gconst41*x702);
IkReal x706=(x702*x703);
evalcond[0]=(((new_r01*x701))+gconst41+((new_r11*x702)));
evalcond[1]=(((gconst42*x701))+x705+new_r11);
evalcond[2]=((((-1.0)*x706))+x704);
evalcond[3]=((((-1.0)*x706))+x704+new_r01);
evalcond[4]=((((-1.0)*x705))+(((-1.0)*x701*x703)));
evalcond[5]=((((-1.0)*new_r01*x702))+gconst42+((new_r11*x701)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x707=IKPowWithIntegerCheck(gconst42,-1);
if(!x707.valid){
continue;
}
cj1array[0]=(new_r00*(x707.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x708=IKsin(j1);
IkReal x709=IKcos(j1);
IkReal x710=((-1.0)*x708);
evalcond[0]=(new_r11*x708);
evalcond[1]=(gconst42*x710);
evalcond[2]=(new_r00*x710);
evalcond[3]=(((gconst42*x709))+new_r11);
evalcond[4]=(gconst42+((new_r11*x709)));
evalcond[5]=((((-1.0)*gconst42))+((new_r00*x709)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
CheckValue<IkReal> x712 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x712.valid){
continue;
}
IkReal x711=((-1.0)*(x712.value));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=gconst41;
cj3=gconst42;
j3=x711;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst40=x711;
IkReal gconst41=0;
IkReal x713 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x713)==0){
continue;
}
IkReal gconst42=(new_r11*(pow(x713,-0.5)));
j1eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x715 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x715.valid){
continue;
}
IkReal x714=((-1.0)*(x715.value));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=gconst41;
cj3=gconst42;
j3=x714;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst40=x714;
IkReal gconst41=0;
IkReal x716 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x716)==0){
continue;
}
IkReal gconst42=(new_r11*(pow(x716,-0.5)));
j1eval[0]=new_r11;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x718 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x718.valid){
continue;
}
IkReal x717=((-1.0)*(x718.value));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=gconst41;
cj3=gconst42;
j3=x717;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst40=x717;
IkReal gconst41=0;
IkReal x719 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x719)==0){
continue;
}
IkReal gconst42=(new_r11*(pow(x719,-0.5)));
j1eval[0]=new_r10;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x720=IKPowWithIntegerCheck(new_r10,-1);
if(!x720.valid){
continue;
}
CheckValue<IkReal> x721=IKPowWithIntegerCheck(gconst42,-1);
if(!x721.valid){
continue;
}
if( IKabs((gconst42*(x720.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11*(x721.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((gconst42*(x720.value)))+IKsqr(((-1.0)*new_r11*(x721.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((gconst42*(x720.value)), ((-1.0)*new_r11*(x721.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x722=IKsin(j1);
IkReal x723=IKcos(j1);
IkReal x724=((1.0)*gconst42);
IkReal x725=((-1.0)*gconst42);
evalcond[0]=(new_r11*x722);
evalcond[1]=(new_r10*x723);
evalcond[2]=(x722*x725);
evalcond[3]=(x723*x725);
evalcond[4]=(((gconst42*x723))+new_r11);
evalcond[5]=(gconst42+((new_r11*x723)));
evalcond[6]=((((-1.0)*x722*x724))+new_r10);
evalcond[7]=((((-1.0)*x724))+((new_r10*x722)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x726=IKPowWithIntegerCheck(gconst42,-1);
if(!x726.valid){
continue;
}
CheckValue<IkReal> x727=IKPowWithIntegerCheck(new_r11,-1);
if(!x727.valid){
continue;
}
if( IKabs((new_r10*(x726.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst42*(x727.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x726.value)))+IKsqr(((-1.0)*gconst42*(x727.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((new_r10*(x726.value)), ((-1.0)*gconst42*(x727.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x728=IKsin(j1);
IkReal x729=IKcos(j1);
IkReal x730=((1.0)*gconst42);
IkReal x731=((-1.0)*gconst42);
evalcond[0]=(new_r11*x728);
evalcond[1]=(new_r10*x729);
evalcond[2]=(x728*x731);
evalcond[3]=(x729*x731);
evalcond[4]=(((gconst42*x729))+new_r11);
evalcond[5]=(gconst42+((new_r11*x729)));
evalcond[6]=(new_r10+(((-1.0)*x728*x730)));
evalcond[7]=((((-1.0)*x730))+((new_r10*x728)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x732=IKPowWithIntegerCheck(IKsign(gconst42),-1);
if(!x732.valid){
continue;
}
CheckValue<IkReal> x733 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x733.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x732.value)))+(x733.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x734=IKsin(j1);
IkReal x735=IKcos(j1);
IkReal x736=((1.0)*gconst42);
IkReal x737=((-1.0)*gconst42);
evalcond[0]=(new_r11*x734);
evalcond[1]=(new_r10*x735);
evalcond[2]=(x734*x737);
evalcond[3]=(x735*x737);
evalcond[4]=(((gconst42*x735))+new_r11);
evalcond[5]=(gconst42+((new_r11*x735)));
evalcond[6]=((((-1.0)*x734*x736))+new_r10);
evalcond[7]=((((-1.0)*x736))+((new_r10*x734)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r01);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
CheckValue<IkReal> x739 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x739.valid){
continue;
}
IkReal x738=((-1.0)*(x739.value));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=gconst41;
cj3=gconst42;
j3=x738;
new_r01=0;
IkReal gconst40=x738;
IkReal gconst41=0;
IkReal x740 = new_r11*new_r11;
if(IKabs(x740)==0){
continue;
}
IkReal gconst42=(new_r11*(pow(x740,-0.5)));
j1eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x742 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x742.valid){
continue;
}
IkReal x741=((-1.0)*(x742.value));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=gconst41;
cj3=gconst42;
j3=x741;
new_r01=0;
IkReal gconst40=x741;
IkReal gconst41=0;
IkReal x743 = new_r11*new_r11;
if(IKabs(x743)==0){
continue;
}
IkReal gconst42=(new_r11*(pow(x743,-0.5)));
j1eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x745 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x745.valid){
continue;
}
IkReal x744=((-1.0)*(x745.value));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=gconst41;
cj3=gconst42;
j3=x744;
new_r01=0;
IkReal gconst40=x744;
IkReal gconst41=0;
IkReal x746 = new_r11*new_r11;
if(IKabs(x746)==0){
continue;
}
IkReal gconst42=(new_r11*(pow(x746,-0.5)));
j1eval[0]=new_r11;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x747=IKPowWithIntegerCheck(gconst42,-1);
if(!x747.valid){
continue;
}
CheckValue<IkReal> x748=IKPowWithIntegerCheck(new_r11,-1);
if(!x748.valid){
continue;
}
if( IKabs((new_r10*(x747.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst42*(x748.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x747.value)))+IKsqr(((-1.0)*gconst42*(x748.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((new_r10*(x747.value)), ((-1.0)*gconst42*(x748.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x749=IKsin(j1);
IkReal x750=IKcos(j1);
IkReal x751=((1.0)*gconst42);
evalcond[0]=(new_r11*x749);
evalcond[1]=((-1.0)*gconst42*x749);
evalcond[2]=(((gconst42*x750))+new_r11);
evalcond[3]=(gconst42+((new_r11*x750)));
evalcond[4]=((((-1.0)*x750*x751))+new_r00);
evalcond[5]=(new_r10+(((-1.0)*x749*x751)));
evalcond[6]=((((-1.0)*new_r00*x749))+((new_r10*x750)));
evalcond[7]=(((new_r00*x750))+((new_r10*x749))+(((-1.0)*x751)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x752=IKPowWithIntegerCheck(IKsign(gconst42),-1);
if(!x752.valid){
continue;
}
CheckValue<IkReal> x753 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x753.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x752.value)))+(x753.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x754=IKsin(j1);
IkReal x755=IKcos(j1);
IkReal x756=((1.0)*gconst42);
evalcond[0]=(new_r11*x754);
evalcond[1]=((-1.0)*gconst42*x754);
evalcond[2]=(((gconst42*x755))+new_r11);
evalcond[3]=(gconst42+((new_r11*x755)));
evalcond[4]=((((-1.0)*x755*x756))+new_r00);
evalcond[5]=((((-1.0)*x754*x756))+new_r10);
evalcond[6]=((((-1.0)*new_r00*x754))+((new_r10*x755)));
evalcond[7]=(((new_r00*x755))+((new_r10*x754))+(((-1.0)*x756)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x757=IKPowWithIntegerCheck(IKsign(gconst42),-1);
if(!x757.valid){
continue;
}
CheckValue<IkReal> x758 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x758.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x757.value)))+(x758.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x759=IKsin(j1);
IkReal x760=IKcos(j1);
IkReal x761=((1.0)*gconst42);
evalcond[0]=(new_r11*x759);
evalcond[1]=((-1.0)*gconst42*x759);
evalcond[2]=(((gconst42*x760))+new_r11);
evalcond[3]=(((new_r11*x760))+gconst42);
evalcond[4]=(new_r00+(((-1.0)*x760*x761)));
evalcond[5]=(new_r10+(((-1.0)*x759*x761)));
evalcond[6]=(((new_r10*x760))+(((-1.0)*new_r00*x759)));
evalcond[7]=((((-1.0)*x761))+((new_r00*x760))+((new_r10*x759)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x762=((1.0)*gconst41);
CheckValue<IkReal> x763 = IKatan2WithCheck(IkReal((((gconst42*new_r01))+(((-1.0)*new_r11*x762)))),IkReal(((((-1.0)*gconst42*new_r11))+(((-1.0)*new_r01*x762)))),IKFAST_ATAN2_MAGTHRESH);
if(!x763.valid){
continue;
}
CheckValue<IkReal> x764=IKPowWithIntegerCheck(IKsign(((gconst42*gconst42)+(gconst41*gconst41))),-1);
if(!x764.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x763.value)+(((1.5707963267949)*(x764.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x765=IKcos(j1);
IkReal x766=IKsin(j1);
IkReal x767=((1.0)*gconst42);
IkReal x768=(gconst41*x765);
IkReal x769=(gconst41*x766);
IkReal x770=((1.0)*x766);
IkReal x771=(x766*x767);
evalcond[0]=(((new_r11*x766))+gconst41+((new_r01*x765)));
evalcond[1]=(((gconst42*x765))+x769+new_r11);
evalcond[2]=(x768+(((-1.0)*x771))+new_r01);
evalcond[3]=(((new_r10*x765))+(((-1.0)*new_r00*x770))+gconst41);
evalcond[4]=(((new_r11*x765))+(((-1.0)*new_r01*x770))+gconst42);
evalcond[5]=(x768+(((-1.0)*x771))+new_r10);
evalcond[6]=(((new_r10*x766))+(((-1.0)*x767))+((new_r00*x765)));
evalcond[7]=((((-1.0)*x765*x767))+(((-1.0)*x769))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x772=((1.0)*gconst41);
CheckValue<IkReal> x773=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x773.valid){
continue;
}
CheckValue<IkReal> x774 = IKatan2WithCheck(IkReal((((gconst42*new_r01))+(((-1.0)*new_r11*x772)))),IkReal(((((-1.0)*new_r01*x772))+(((-1.0)*gconst42*new_r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x774.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x773.value)))+(x774.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x775=IKcos(j1);
IkReal x776=IKsin(j1);
IkReal x777=((1.0)*gconst42);
IkReal x778=(gconst41*x775);
IkReal x779=(gconst41*x776);
IkReal x780=((1.0)*x776);
IkReal x781=(x776*x777);
evalcond[0]=(gconst41+((new_r11*x776))+((new_r01*x775)));
evalcond[1]=(((gconst42*x775))+x779+new_r11);
evalcond[2]=((((-1.0)*x781))+x778+new_r01);
evalcond[3]=(gconst41+((new_r10*x775))+(((-1.0)*new_r00*x780)));
evalcond[4]=((((-1.0)*new_r01*x780))+gconst42+((new_r11*x775)));
evalcond[5]=((((-1.0)*x781))+x778+new_r10);
evalcond[6]=(((new_r00*x775))+((new_r10*x776))+(((-1.0)*x777)));
evalcond[7]=((((-1.0)*x775*x777))+new_r00+(((-1.0)*x779)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x782=((1.0)*gconst41);
CheckValue<IkReal> x783 = IKatan2WithCheck(IkReal((((gconst41*new_r01))+(((-1.0)*new_r10*x782)))),IkReal(((((-1.0)*new_r11*x782))+(((-1.0)*new_r00*x782)))),IKFAST_ATAN2_MAGTHRESH);
if(!x783.valid){
continue;
}
CheckValue<IkReal> x784=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x784.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x783.value)+(((1.5707963267949)*(x784.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x785=IKcos(j1);
IkReal x786=IKsin(j1);
IkReal x787=((1.0)*gconst42);
IkReal x788=(gconst41*x785);
IkReal x789=(gconst41*x786);
IkReal x790=((1.0)*x786);
IkReal x791=(x786*x787);
evalcond[0]=(((new_r11*x786))+gconst41+((new_r01*x785)));
evalcond[1]=(((gconst42*x785))+x789+new_r11);
evalcond[2]=((((-1.0)*x791))+x788+new_r01);
evalcond[3]=(((new_r10*x785))+gconst41+(((-1.0)*new_r00*x790)));
evalcond[4]=((((-1.0)*new_r01*x790))+((new_r11*x785))+gconst42);
evalcond[5]=((((-1.0)*x791))+x788+new_r10);
evalcond[6]=(((new_r10*x786))+(((-1.0)*x787))+((new_r00*x785)));
evalcond[7]=((((-1.0)*x789))+new_r00+(((-1.0)*x785*x787)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x793 = ((new_r01*new_r01)+(new_r11*new_r11));
if(IKabs(x793)==0){
continue;
}
IkReal x792=pow(x793,-0.5);
CheckValue<IkReal> x794 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x794.valid){
continue;
}
IkReal gconst43=((3.14159265358979)+(((-1.0)*(x794.value))));
IkReal gconst44=((1.0)*new_r01*x792);
IkReal gconst45=((-1.0)*new_r11*x792);
CheckValue<IkReal> x795 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x795.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x795.value)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
CheckValue<IkReal> x798 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x798.valid){
continue;
}
IkReal x796=((1.0)*(x798.value));
IkReal x797=x792;
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=gconst44;
cj3=gconst45;
j3=((3.14159265)+(((-1.0)*x796)));
IkReal gconst43=((3.14159265358979)+(((-1.0)*x796)));
IkReal gconst44=((1.0)*new_r01*x797);
IkReal gconst45=((-1.0)*new_r11*x797);
IkReal x799=new_r01*new_r01;
IkReal x800=(((new_r10*new_r11))+((new_r00*new_r01)));
IkReal x801=x792;
IkReal x802=((1.0)*new_r01*x801);
j1eval[0]=x800;
j1eval[1]=((IKabs(((((-1.0)*new_r00*x802))+(((-1.0)*new_r11*x802)))))+(IKabs((((x799*x801))+(((-1.0)*new_r10*x802))))));
j1eval[2]=IKsign(x800);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
CheckValue<IkReal> x805 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x805.valid){
continue;
}
IkReal x803=((1.0)*(x805.value));
IkReal x804=x792;
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=gconst44;
cj3=gconst45;
j3=((3.14159265)+(((-1.0)*x803)));
IkReal gconst43=((3.14159265358979)+(((-1.0)*x803)));
IkReal gconst44=((1.0)*new_r01*x804);
IkReal gconst45=((-1.0)*new_r11*x804);
IkReal x806=((new_r01*new_r01)+(new_r11*new_r11));
j1eval[0]=x806;
j1eval[1]=IKsign(x806);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x809 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x809.valid){
continue;
}
IkReal x807=((1.0)*(x809.value));
IkReal x808=x792;
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=gconst44;
cj3=gconst45;
j3=((3.14159265)+(((-1.0)*x807)));
IkReal gconst43=((3.14159265358979)+(((-1.0)*x807)));
IkReal gconst44=((1.0)*new_r01*x808);
IkReal gconst45=((-1.0)*new_r11*x808);
j1eval[0]=((new_r01*new_r01)+(new_r11*new_r11));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((gconst45*gconst45)+(gconst44*gconst44));
evalcond[1]=new_r01;
evalcond[2]=new_r00;
evalcond[3]=new_r11;
evalcond[4]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[4], cj1array[4], sj1array[4];
bool j1valid[4]={false};
_nj1 = 4;
j1array[0]=0;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=1.5707963267949;
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
j1array[2]=3.14159265358979;
sj1array[2]=IKsin(j1array[2]);
cj1array[2]=IKcos(j1array[2]);
j1array[3]=-1.5707963267949;
sj1array[3]=IKsin(j1array[3]);
cj1array[3]=IKcos(j1array[3]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
if( j1array[2] > IKPI )
{
    j1array[2]-=IK2PI;
}
else if( j1array[2] < -IKPI )
{    j1array[2]+=IK2PI;
}
j1valid[2] = true;
if( j1array[3] > IKPI )
{
    j1array[3]-=IK2PI;
}
else if( j1array[3] < -IKPI )
{    j1array[3]+=IK2PI;
}
j1valid[3] = true;
for(int ij1 = 0; ij1 < 4; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 4; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
CheckValue<IkReal> x811 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x811.valid){
continue;
}
IkReal x810=((1.0)*(x811.value));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=gconst44;
cj3=gconst45;
j3=((3.14159265)+(((-1.0)*x810)));
new_r11=0;
new_r00=0;
IkReal gconst43=((3.14159265358979)+(((-1.0)*x810)));
IkReal x812 = new_r01*new_r01;
if(IKabs(x812)==0){
continue;
}
IkReal gconst44=((1.0)*new_r01*(pow(x812,-0.5)));
IkReal gconst45=0;
j1eval[0]=new_r01;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x813=IKPowWithIntegerCheck(gconst44,-1);
if(!x813.valid){
continue;
}
cj1array[0]=((-1.0)*new_r01*(x813.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x814=IKsin(j1);
IkReal x815=IKcos(j1);
IkReal x816=((-1.0)*x814);
evalcond[0]=(new_r10*x814);
evalcond[1]=(gconst44*x816);
evalcond[2]=(new_r01*x816);
evalcond[3]=(((new_r01*x815))+gconst44);
evalcond[4]=(((new_r10*x815))+gconst44);
evalcond[5]=(((gconst44*x815))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x817=IKPowWithIntegerCheck(new_r01,-1);
if(!x817.valid){
continue;
}
cj1array[0]=((-1.0)*gconst44*(x817.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x818=IKsin(j1);
IkReal x819=IKcos(j1);
IkReal x820=(gconst44*x819);
IkReal x821=((-1.0)*x818);
evalcond[0]=(new_r10*x818);
evalcond[1]=(gconst44*x821);
evalcond[2]=(new_r01*x821);
evalcond[3]=(new_r01+x820);
evalcond[4]=(((new_r10*x819))+gconst44);
evalcond[5]=(new_r10+x820);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
evalcond[1]=gconst44;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[4];
CheckValue<IkReal> x823 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x823.valid){
continue;
}
IkReal x822=((1.0)*(x823.value));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=gconst44;
cj3=gconst45;
j3=((3.14159265)+(((-1.0)*x822)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst43=((3.14159265358979)+(((-1.0)*x822)));
IkReal gconst44=((1.0)*new_r01);
IkReal gconst45=((-1.0)*new_r11);
j1eval[0]=1.0;
j1eval[1]=new_r01;
j1eval[2]=1.0;
j1eval[3]=1.0;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  || IKabs(j1eval[3]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
CheckValue<IkReal> x825 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x825.valid){
continue;
}
IkReal x824=((1.0)*(x825.value));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=gconst44;
cj3=gconst45;
j3=((3.14159265)+(((-1.0)*x824)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst43=((3.14159265358979)+(((-1.0)*x824)));
IkReal gconst44=((1.0)*new_r01);
IkReal gconst45=((-1.0)*new_r11);
j1eval[0]=-1.0;
j1eval[1]=-1.0;
j1eval[2]=((IKabs(((-1.0)+(new_r01*new_r01))))+(IKabs(((1.0)*new_r01*new_r11))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
CheckValue<IkReal> x827 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x827.valid){
continue;
}
IkReal x826=((1.0)*(x827.value));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=gconst44;
cj3=gconst45;
j3=((3.14159265)+(((-1.0)*x826)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst43=((3.14159265358979)+(((-1.0)*x826)));
IkReal gconst44=((1.0)*new_r01);
IkReal gconst45=((-1.0)*new_r11);
j1eval[0]=1.0;
j1eval[1]=((IKabs(((2.0)*new_r01*new_r11)))+(IKabs(((1.0)+(((-2.0)*(new_r01*new_r01)))))));
j1eval[2]=1.0;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x828=((1.0)*new_r11);
CheckValue<IkReal> x829=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x829.valid){
continue;
}
CheckValue<IkReal> x830 = IKatan2WithCheck(IkReal(((((-1.0)*gconst44*x828))+((gconst45*new_r01)))),IkReal(((((-1.0)*gconst44*new_r01))+(((-1.0)*gconst45*x828)))),IKFAST_ATAN2_MAGTHRESH);
if(!x830.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x829.value)))+(x830.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x831=IKsin(j1);
IkReal x832=IKcos(j1);
IkReal x833=(gconst44*x832);
IkReal x834=((1.0)*x831);
IkReal x835=(gconst45*x832);
IkReal x836=(gconst45*x834);
evalcond[0]=(((new_r11*x831))+((new_r01*x832))+gconst44);
evalcond[1]=(new_r11+x835+((gconst44*x831)));
evalcond[2]=((((-1.0)*x836))+x833);
evalcond[3]=((((-1.0)*x836))+new_r01+x833);
evalcond[4]=((((-1.0)*x835))+(((-1.0)*gconst44*x834)));
evalcond[5]=(((new_r11*x832))+gconst45+(((-1.0)*new_r01*x834)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x837 = IKatan2WithCheck(IkReal((gconst44*new_r11)),IkReal((gconst45*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x837.valid){
continue;
}
CheckValue<IkReal> x838=IKPowWithIntegerCheck(IKsign(((((-1.0)*(gconst45*gconst45)))+(((-1.0)*(gconst44*gconst44))))),-1);
if(!x838.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x837.value)+(((1.5707963267949)*(x838.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x839=IKsin(j1);
IkReal x840=IKcos(j1);
IkReal x841=(gconst44*x840);
IkReal x842=((1.0)*x839);
IkReal x843=(gconst45*x840);
IkReal x844=(gconst45*x842);
evalcond[0]=(((new_r11*x839))+gconst44+((new_r01*x840)));
evalcond[1]=(new_r11+x843+((gconst44*x839)));
evalcond[2]=((((-1.0)*x844))+x841);
evalcond[3]=((((-1.0)*x844))+new_r01+x841);
evalcond[4]=((((-1.0)*x843))+(((-1.0)*gconst44*x842)));
evalcond[5]=(gconst45+(((-1.0)*new_r01*x842))+((new_r11*x840)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x845 = IKatan2WithCheck(IkReal((gconst44*gconst45)),IkReal(((-1.0)*(gconst44*gconst44))),IKFAST_ATAN2_MAGTHRESH);
if(!x845.valid){
continue;
}
CheckValue<IkReal> x846=IKPowWithIntegerCheck(IKsign((((gconst44*new_r01))+(((-1.0)*gconst45*new_r11)))),-1);
if(!x846.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x845.value)+(((1.5707963267949)*(x846.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x847=IKsin(j1);
IkReal x848=IKcos(j1);
IkReal x849=(gconst44*x848);
IkReal x850=((1.0)*x847);
IkReal x851=(gconst45*x848);
IkReal x852=(gconst45*x850);
evalcond[0]=(gconst44+((new_r01*x848))+((new_r11*x847)));
evalcond[1]=(new_r11+x851+((gconst44*x847)));
evalcond[2]=((((-1.0)*x852))+x849);
evalcond[3]=((((-1.0)*x852))+new_r01+x849);
evalcond[4]=((((-1.0)*x851))+(((-1.0)*gconst44*x850)));
evalcond[5]=((((-1.0)*new_r01*x850))+gconst45+((new_r11*x848)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x853=IKPowWithIntegerCheck(gconst45,-1);
if(!x853.valid){
continue;
}
cj1array[0]=(new_r00*(x853.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x854=IKsin(j1);
IkReal x855=IKcos(j1);
IkReal x856=((-1.0)*x854);
evalcond[0]=(new_r11*x854);
evalcond[1]=(gconst45*x856);
evalcond[2]=(new_r00*x856);
evalcond[3]=(((gconst45*x855))+new_r11);
evalcond[4]=(gconst45+((new_r11*x855)));
evalcond[5]=((((-1.0)*gconst45))+((new_r00*x855)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
CheckValue<IkReal> x858 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x858.valid){
continue;
}
IkReal x857=((1.0)*(x858.value));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=gconst44;
cj3=gconst45;
j3=((3.14159265)+(((-1.0)*x857)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst43=((3.14159265358979)+(((-1.0)*x857)));
IkReal gconst44=0;
IkReal x859 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x859)==0){
continue;
}
IkReal gconst45=((-1.0)*new_r11*(pow(x859,-0.5)));
j1eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x861 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x861.valid){
continue;
}
IkReal x860=((1.0)*(x861.value));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=gconst44;
cj3=gconst45;
j3=((3.14159265)+(((-1.0)*x860)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst43=((3.14159265358979)+(((-1.0)*x860)));
IkReal gconst44=0;
IkReal x862 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x862)==0){
continue;
}
IkReal gconst45=((-1.0)*new_r11*(pow(x862,-0.5)));
j1eval[0]=new_r11;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x864 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x864.valid){
continue;
}
IkReal x863=((1.0)*(x864.value));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=gconst44;
cj3=gconst45;
j3=((3.14159265)+(((-1.0)*x863)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst43=((3.14159265358979)+(((-1.0)*x863)));
IkReal gconst44=0;
IkReal x865 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x865)==0){
continue;
}
IkReal gconst45=((-1.0)*new_r11*(pow(x865,-0.5)));
j1eval[0]=new_r10;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x866=IKPowWithIntegerCheck(new_r10,-1);
if(!x866.valid){
continue;
}
CheckValue<IkReal> x867=IKPowWithIntegerCheck(gconst45,-1);
if(!x867.valid){
continue;
}
if( IKabs((gconst45*(x866.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11*(x867.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((gconst45*(x866.value)))+IKsqr(((-1.0)*new_r11*(x867.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((gconst45*(x866.value)), ((-1.0)*new_r11*(x867.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x868=IKsin(j1);
IkReal x869=IKcos(j1);
IkReal x870=((1.0)*gconst45);
IkReal x871=(gconst45*x869);
evalcond[0]=(new_r11*x868);
evalcond[1]=(new_r10*x869);
evalcond[2]=((-1.0)*gconst45*x868);
evalcond[3]=((-1.0)*x871);
evalcond[4]=(new_r11+x871);
evalcond[5]=(gconst45+((new_r11*x869)));
evalcond[6]=((((-1.0)*x868*x870))+new_r10);
evalcond[7]=(((new_r10*x868))+(((-1.0)*x870)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x872=IKPowWithIntegerCheck(gconst45,-1);
if(!x872.valid){
continue;
}
CheckValue<IkReal> x873=IKPowWithIntegerCheck(new_r11,-1);
if(!x873.valid){
continue;
}
if( IKabs((new_r10*(x872.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst45*(x873.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x872.value)))+IKsqr(((-1.0)*gconst45*(x873.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((new_r10*(x872.value)), ((-1.0)*gconst45*(x873.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x874=IKsin(j1);
IkReal x875=IKcos(j1);
IkReal x876=((1.0)*gconst45);
IkReal x877=(gconst45*x875);
evalcond[0]=(new_r11*x874);
evalcond[1]=(new_r10*x875);
evalcond[2]=((-1.0)*gconst45*x874);
evalcond[3]=((-1.0)*x877);
evalcond[4]=(new_r11+x877);
evalcond[5]=(gconst45+((new_r11*x875)));
evalcond[6]=((((-1.0)*x874*x876))+new_r10);
evalcond[7]=(((new_r10*x874))+(((-1.0)*x876)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x878 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x878.valid){
continue;
}
CheckValue<IkReal> x879=IKPowWithIntegerCheck(IKsign(gconst45),-1);
if(!x879.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x878.value)+(((1.5707963267949)*(x879.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x880=IKsin(j1);
IkReal x881=IKcos(j1);
IkReal x882=((1.0)*gconst45);
IkReal x883=(gconst45*x881);
evalcond[0]=(new_r11*x880);
evalcond[1]=(new_r10*x881);
evalcond[2]=((-1.0)*gconst45*x880);
evalcond[3]=((-1.0)*x883);
evalcond[4]=(new_r11+x883);
evalcond[5]=(((new_r11*x881))+gconst45);
evalcond[6]=(new_r10+(((-1.0)*x880*x882)));
evalcond[7]=(((new_r10*x880))+(((-1.0)*x882)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r01);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
CheckValue<IkReal> x885 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x885.valid){
continue;
}
IkReal x884=((1.0)*(x885.value));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=gconst44;
cj3=gconst45;
j3=((3.14159265)+(((-1.0)*x884)));
new_r01=0;
IkReal gconst43=((3.14159265358979)+(((-1.0)*x884)));
IkReal gconst44=0;
IkReal x886 = new_r11*new_r11;
if(IKabs(x886)==0){
continue;
}
IkReal gconst45=((-1.0)*new_r11*(pow(x886,-0.5)));
j1eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x888 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x888.valid){
continue;
}
IkReal x887=((1.0)*(x888.value));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=gconst44;
cj3=gconst45;
j3=((3.14159265)+(((-1.0)*x887)));
new_r01=0;
IkReal gconst43=((3.14159265358979)+(((-1.0)*x887)));
IkReal gconst44=0;
IkReal x889 = new_r11*new_r11;
if(IKabs(x889)==0){
continue;
}
IkReal gconst45=((-1.0)*new_r11*(pow(x889,-0.5)));
j1eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x891 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x891.valid){
continue;
}
IkReal x890=((1.0)*(x891.value));
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=gconst44;
cj3=gconst45;
j3=((3.14159265)+(((-1.0)*x890)));
new_r01=0;
IkReal gconst43=((3.14159265358979)+(((-1.0)*x890)));
IkReal gconst44=0;
IkReal x892 = new_r11*new_r11;
if(IKabs(x892)==0){
continue;
}
IkReal gconst45=((-1.0)*new_r11*(pow(x892,-0.5)));
j1eval[0]=new_r11;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x893=IKPowWithIntegerCheck(gconst45,-1);
if(!x893.valid){
continue;
}
CheckValue<IkReal> x894=IKPowWithIntegerCheck(new_r11,-1);
if(!x894.valid){
continue;
}
if( IKabs((new_r10*(x893.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst45*(x894.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x893.value)))+IKsqr(((-1.0)*gconst45*(x894.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((new_r10*(x893.value)), ((-1.0)*gconst45*(x894.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x895=IKsin(j1);
IkReal x896=IKcos(j1);
IkReal x897=(gconst45*x895);
IkReal x898=(gconst45*x896);
evalcond[0]=(new_r11*x895);
evalcond[1]=((-1.0)*x897);
evalcond[2]=(new_r11+x898);
evalcond[3]=(((new_r11*x896))+gconst45);
evalcond[4]=((((-1.0)*x898))+new_r00);
evalcond[5]=((((-1.0)*x897))+new_r10);
evalcond[6]=((((-1.0)*new_r00*x895))+((new_r10*x896)));
evalcond[7]=((((-1.0)*gconst45))+((new_r00*x896))+((new_r10*x895)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x899 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x899.valid){
continue;
}
CheckValue<IkReal> x900=IKPowWithIntegerCheck(IKsign(gconst45),-1);
if(!x900.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x899.value)+(((1.5707963267949)*(x900.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x901=IKsin(j1);
IkReal x902=IKcos(j1);
IkReal x903=(gconst45*x901);
IkReal x904=(gconst45*x902);
evalcond[0]=(new_r11*x901);
evalcond[1]=((-1.0)*x903);
evalcond[2]=(new_r11+x904);
evalcond[3]=(gconst45+((new_r11*x902)));
evalcond[4]=((((-1.0)*x904))+new_r00);
evalcond[5]=((((-1.0)*x903))+new_r10);
evalcond[6]=(((new_r10*x902))+(((-1.0)*new_r00*x901)));
evalcond[7]=((((-1.0)*gconst45))+((new_r10*x901))+((new_r00*x902)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x905=IKPowWithIntegerCheck(IKsign(gconst45),-1);
if(!x905.valid){
continue;
}
CheckValue<IkReal> x906 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x906.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x905.value)))+(x906.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x907=IKsin(j1);
IkReal x908=IKcos(j1);
IkReal x909=(gconst45*x907);
IkReal x910=(gconst45*x908);
evalcond[0]=(new_r11*x907);
evalcond[1]=((-1.0)*x909);
evalcond[2]=(new_r11+x910);
evalcond[3]=(gconst45+((new_r11*x908)));
evalcond[4]=((((-1.0)*x910))+new_r00);
evalcond[5]=((((-1.0)*x909))+new_r10);
evalcond[6]=(((new_r10*x908))+(((-1.0)*new_r00*x907)));
evalcond[7]=((((-1.0)*gconst45))+((new_r10*x907))+((new_r00*x908)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x911=((1.0)*new_r11);
CheckValue<IkReal> x912 = IKatan2WithCheck(IkReal(((((-1.0)*gconst44*x911))+((gconst45*new_r01)))),IkReal(((((-1.0)*gconst44*new_r01))+(((-1.0)*gconst45*x911)))),IKFAST_ATAN2_MAGTHRESH);
if(!x912.valid){
continue;
}
CheckValue<IkReal> x913=IKPowWithIntegerCheck(IKsign(((gconst45*gconst45)+(gconst44*gconst44))),-1);
if(!x913.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x912.value)+(((1.5707963267949)*(x913.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x914=IKsin(j1);
IkReal x915=IKcos(j1);
IkReal x916=(gconst44*x915);
IkReal x917=((1.0)*x914);
IkReal x918=(gconst45*x915);
IkReal x919=(gconst45*x917);
evalcond[0]=(gconst44+((new_r11*x914))+((new_r01*x915)));
evalcond[1]=(new_r11+((gconst44*x914))+x918);
evalcond[2]=((((-1.0)*x919))+new_r01+x916);
evalcond[3]=(gconst44+((new_r10*x915))+(((-1.0)*new_r00*x917)));
evalcond[4]=(gconst45+((new_r11*x915))+(((-1.0)*new_r01*x917)));
evalcond[5]=((((-1.0)*x919))+new_r10+x916);
evalcond[6]=((((-1.0)*gconst45))+((new_r10*x914))+((new_r00*x915)));
evalcond[7]=((((-1.0)*gconst44*x917))+(((-1.0)*x918))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x920=((1.0)*new_r11);
CheckValue<IkReal> x921 = IKatan2WithCheck(IkReal(((((-1.0)*gconst44*x920))+((gconst45*new_r01)))),IkReal(((((-1.0)*gconst44*new_r01))+(((-1.0)*gconst45*x920)))),IKFAST_ATAN2_MAGTHRESH);
if(!x921.valid){
continue;
}
CheckValue<IkReal> x922=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x922.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x921.value)+(((1.5707963267949)*(x922.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x923=IKsin(j1);
IkReal x924=IKcos(j1);
IkReal x925=(gconst44*x924);
IkReal x926=((1.0)*x923);
IkReal x927=(gconst45*x924);
IkReal x928=(gconst45*x926);
evalcond[0]=(gconst44+((new_r01*x924))+((new_r11*x923)));
evalcond[1]=(((gconst44*x923))+new_r11+x927);
evalcond[2]=((((-1.0)*x928))+new_r01+x925);
evalcond[3]=(gconst44+(((-1.0)*new_r00*x926))+((new_r10*x924)));
evalcond[4]=(gconst45+(((-1.0)*new_r01*x926))+((new_r11*x924)));
evalcond[5]=((((-1.0)*x928))+new_r10+x925);
evalcond[6]=((((-1.0)*gconst45))+((new_r00*x924))+((new_r10*x923)));
evalcond[7]=((((-1.0)*gconst44*x926))+(((-1.0)*x927))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x929=((1.0)*gconst44);
CheckValue<IkReal> x930 = IKatan2WithCheck(IkReal((((gconst44*new_r01))+(((-1.0)*new_r10*x929)))),IkReal(((((-1.0)*new_r11*x929))+(((-1.0)*new_r00*x929)))),IKFAST_ATAN2_MAGTHRESH);
if(!x930.valid){
continue;
}
CheckValue<IkReal> x931=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x931.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x930.value)+(((1.5707963267949)*(x931.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x932=IKsin(j1);
IkReal x933=IKcos(j1);
IkReal x934=(gconst44*x933);
IkReal x935=((1.0)*x932);
IkReal x936=(gconst45*x933);
IkReal x937=(gconst45*x935);
evalcond[0]=(gconst44+((new_r01*x933))+((new_r11*x932)));
evalcond[1]=(((gconst44*x932))+new_r11+x936);
evalcond[2]=(new_r01+x934+(((-1.0)*x937)));
evalcond[3]=(gconst44+(((-1.0)*new_r00*x935))+((new_r10*x933)));
evalcond[4]=(gconst45+(((-1.0)*new_r01*x935))+((new_r11*x933)));
evalcond[5]=(new_r10+x934+(((-1.0)*x937)));
evalcond[6]=((((-1.0)*gconst45))+((new_r00*x933))+((new_r10*x932)));
evalcond[7]=((((-1.0)*gconst44*x935))+(((-1.0)*x936))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
new_r11=0;
new_r01=0;
new_r22=0;
new_r20=0;
j1eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x939 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x939.valid){
continue;
}
IkReal x938=x939.value;
j1array[0]=((-1.0)*x938);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x938)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r00*(IKsin(j1))))+((new_r10*(IKcos(j1)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x940=((1.0)*sj3);
CheckValue<IkReal> x941=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x941.valid){
continue;
}
CheckValue<IkReal> x942 = IKatan2WithCheck(IkReal(((((-1.0)*new_r11*x940))+((cj3*new_r01)))),IkReal(((((-1.0)*cj3*new_r11))+(((-1.0)*new_r01*x940)))),IKFAST_ATAN2_MAGTHRESH);
if(!x942.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x941.value)))+(x942.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x943=IKcos(j1);
IkReal x944=IKsin(j1);
IkReal x945=(sj3*x943);
IkReal x946=((1.0)*x944);
IkReal x947=(cj3*x943);
IkReal x948=(cj3*x946);
evalcond[0]=(sj3+((new_r01*x943))+((new_r11*x944)));
evalcond[1]=(((sj3*x944))+new_r11+x947);
evalcond[2]=((((-1.0)*x948))+new_r01+x945);
evalcond[3]=(sj3+((new_r10*x943))+(((-1.0)*new_r00*x946)));
evalcond[4]=(cj3+((new_r11*x943))+(((-1.0)*new_r01*x946)));
evalcond[5]=((((-1.0)*x948))+new_r10+x945);
evalcond[6]=(((new_r00*x943))+((new_r10*x944))+(((-1.0)*cj3)));
evalcond[7]=((((-1.0)*x947))+new_r00+(((-1.0)*sj3*x946)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x949=((1.0)*sj3);
CheckValue<IkReal> x950 = IKatan2WithCheck(IkReal((((new_r01*sj3))+(((-1.0)*new_r10*x949)))),IkReal(((((-1.0)*new_r11*x949))+(((-1.0)*new_r00*x949)))),IKFAST_ATAN2_MAGTHRESH);
if(!x950.valid){
continue;
}
CheckValue<IkReal> x951=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x951.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x950.value)+(((1.5707963267949)*(x951.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x952=IKcos(j1);
IkReal x953=IKsin(j1);
IkReal x954=(sj3*x952);
IkReal x955=((1.0)*x953);
IkReal x956=(cj3*x952);
IkReal x957=(cj3*x955);
evalcond[0]=(sj3+((new_r01*x952))+((new_r11*x953)));
evalcond[1]=(((sj3*x953))+new_r11+x956);
evalcond[2]=(new_r01+(((-1.0)*x957))+x954);
evalcond[3]=(((new_r10*x952))+sj3+(((-1.0)*new_r00*x955)));
evalcond[4]=(cj3+(((-1.0)*new_r01*x955))+((new_r11*x952)));
evalcond[5]=(new_r10+(((-1.0)*x957))+x954);
evalcond[6]=(((new_r10*x953))+((new_r00*x952))+(((-1.0)*cj3)));
evalcond[7]=((((-1.0)*x956))+(((-1.0)*sj3*x955))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x958 = IKatan2WithCheck(IkReal(((-1.0)+(cj3*cj3)+(new_r01*new_r01))),IkReal(((((-1.0)*cj3*sj3))+(((-1.0)*new_r01*new_r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x958.valid){
continue;
}
CheckValue<IkReal> x959=IKPowWithIntegerCheck(IKsign((((new_r11*sj3))+((cj3*new_r01)))),-1);
if(!x959.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x958.value)+(((1.5707963267949)*(x959.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x960=IKcos(j1);
IkReal x961=IKsin(j1);
IkReal x962=(sj3*x960);
IkReal x963=((1.0)*x961);
IkReal x964=(cj3*x960);
IkReal x965=(cj3*x963);
evalcond[0]=(((new_r11*x961))+((new_r01*x960))+sj3);
evalcond[1]=(((sj3*x961))+new_r11+x964);
evalcond[2]=(new_r01+x962+(((-1.0)*x965)));
evalcond[3]=(sj3+(((-1.0)*new_r00*x963))+((new_r10*x960)));
evalcond[4]=(((new_r11*x960))+cj3+(((-1.0)*new_r01*x963)));
evalcond[5]=(new_r10+x962+(((-1.0)*x965)));
evalcond[6]=(((new_r00*x960))+(((-1.0)*cj3))+((new_r10*x961)));
evalcond[7]=((((-1.0)*x964))+(((-1.0)*sj3*x963))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j1eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j1eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j1eval[0]=((IKabs((new_r10*new_r22)))+(IKabs((new_r00*new_r22))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x967 = IKatan2WithCheck(IkReal((new_r10*new_r22)),IkReal(((-1.0)*new_r00*new_r22)),IKFAST_ATAN2_MAGTHRESH);
if(!x967.valid){
continue;
}
IkReal x966=x967.value;
j1array[0]=((-1.0)*x966);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x966)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x968=IKcos(j1);
IkReal x969=IKsin(j1);
IkReal x970=(new_r11*x968);
IkReal x971=((1.0)*new_r01*x969);
evalcond[0]=(((new_r11*x969))+((new_r01*x968)));
evalcond[1]=(((new_r00*x968))+((new_r10*x969)));
evalcond[2]=((((-1.0)*new_r00*x969))+((new_r10*x968)));
evalcond[3]=(x970+(((-1.0)*x971)));
evalcond[4]=(((new_r22*x970))+(((-1.0)*new_r22*x971)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x973 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x973.valid){
continue;
}
IkReal x972=x973.value;
j1array[0]=((-1.0)*x972);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x972)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x974=IKcos(j1);
IkReal x975=IKsin(j1);
IkReal x976=(new_r22*x974);
IkReal x977=((1.0)*new_r01*x975);
IkReal x978=((1.0)*new_r00*x975);
evalcond[0]=(((new_r01*x974))+((new_r11*x975)));
evalcond[1]=(((new_r10*x974))+(((-1.0)*x978)));
evalcond[2]=(((new_r11*x974))+(((-1.0)*x977)));
evalcond[3]=((((-1.0)*new_r22*x978))+((new_r10*x976)));
evalcond[4]=(((new_r11*x976))+(((-1.0)*new_r22*x977)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x980 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x980.valid){
continue;
}
IkReal x979=x980.value;
j1array[0]=((-1.0)*x979);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x979)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x981=IKcos(j1);
IkReal x982=IKsin(j1);
IkReal x983=(new_r10*x981);
IkReal x984=(new_r11*x981);
IkReal x985=((1.0)*new_r01*x982);
IkReal x986=((1.0)*new_r00*x982);
evalcond[0]=(((new_r00*x981))+((new_r10*x982)));
evalcond[1]=((((-1.0)*x986))+x983);
evalcond[2]=((((-1.0)*x985))+x984);
evalcond[3]=(((new_r22*x983))+(((-1.0)*new_r22*x986)));
evalcond[4]=(((new_r22*x984))+(((-1.0)*new_r22*x985)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x988=IKPowWithIntegerCheck(sj2,-1);
if(!x988.valid){
continue;
}
IkReal x987=x988.value;
CheckValue<IkReal> x989=IKPowWithIntegerCheck(new_r11,-1);
if(!x989.valid){
continue;
}
if( IKabs((x987*(x989.value)*((((new_r01*new_r12))+(((-1.0)*sj2*sj3)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r12*x987)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x987*(x989.value)*((((new_r01*new_r12))+(((-1.0)*sj2*sj3))))))+IKsqr(((-1.0)*new_r12*x987))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((x987*(x989.value)*((((new_r01*new_r12))+(((-1.0)*sj2*sj3))))), ((-1.0)*new_r12*x987));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[18];
IkReal x990=IKsin(j1);
IkReal x991=IKcos(j1);
IkReal x992=((1.0)*cj3);
IkReal x993=((1.0)*sj2);
IkReal x994=((1.0)*cj2);
IkReal x995=((1.0)*x990);
IkReal x996=(new_r10*x991);
IkReal x997=(cj3*x991);
IkReal x998=(new_r12*x991);
IkReal x999=(sj2*x990);
IkReal x1000=(new_r11*x991);
IkReal x1001=(sj3*x990);
IkReal x1002=(sj3*x991);
evalcond[0]=(((sj2*x991))+new_r12);
evalcond[1]=((((-1.0)*x990*x993))+new_r02);
evalcond[2]=(((new_r12*x990))+((new_r02*x991)));
evalcond[3]=(sj3+((new_r11*x990))+((new_r01*x991)));
evalcond[4]=(sj2+(((-1.0)*new_r02*x995))+x998);
evalcond[5]=(x1002+new_r01+((cj2*cj3*x990)));
evalcond[6]=(((new_r10*x990))+(((-1.0)*x992))+((new_r00*x991)));
evalcond[7]=(((cj2*x1001))+(((-1.0)*x991*x992))+new_r00);
evalcond[8]=(x1001+(((-1.0)*cj2*x991*x992))+new_r11);
evalcond[9]=((((-1.0)*x1002*x994))+(((-1.0)*x990*x992))+new_r10);
evalcond[10]=((((-1.0)*new_r00*x995))+(((-1.0)*sj3*x994))+x996);
evalcond[11]=(x1000+(((-1.0)*new_r01*x995))+(((-1.0)*cj2*x992)));
evalcond[12]=(((new_r22*sj2))+(((-1.0)*new_r02*x990*x994))+((cj2*x998)));
evalcond[13]=(((cj2*new_r20))+((new_r00*x999))+(((-1.0)*x993*x996)));
evalcond[14]=((((-1.0)*x1000*x993))+((cj2*new_r21))+((new_r01*x999)));
evalcond[15]=((-1.0)+((new_r02*x999))+((cj2*new_r22))+(((-1.0)*x993*x998)));
evalcond[16]=((((-1.0)*new_r00*x990*x994))+(((-1.0)*sj3))+((new_r20*sj2))+((cj2*x996)));
evalcond[17]=(((cj2*x1000))+(((-1.0)*x992))+((new_r21*sj2))+(((-1.0)*new_r01*x990*x994)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x1003=IKPowWithIntegerCheck(IKsign(sj2),-1);
if(!x1003.valid){
continue;
}
CheckValue<IkReal> x1004 = IKatan2WithCheck(IkReal(new_r02),IkReal(((-1.0)*new_r12)),IKFAST_ATAN2_MAGTHRESH);
if(!x1004.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1003.value)))+(x1004.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[18];
IkReal x1005=IKsin(j1);
IkReal x1006=IKcos(j1);
IkReal x1007=((1.0)*cj3);
IkReal x1008=((1.0)*sj2);
IkReal x1009=((1.0)*cj2);
IkReal x1010=((1.0)*x1005);
IkReal x1011=(new_r10*x1006);
IkReal x1012=(cj3*x1006);
IkReal x1013=(new_r12*x1006);
IkReal x1014=(sj2*x1005);
IkReal x1015=(new_r11*x1006);
IkReal x1016=(sj3*x1005);
IkReal x1017=(sj3*x1006);
evalcond[0]=(((sj2*x1006))+new_r12);
evalcond[1]=((((-1.0)*x1005*x1008))+new_r02);
evalcond[2]=(((new_r12*x1005))+((new_r02*x1006)));
evalcond[3]=(sj3+((new_r11*x1005))+((new_r01*x1006)));
evalcond[4]=(sj2+x1013+(((-1.0)*new_r02*x1010)));
evalcond[5]=(x1017+((cj2*cj3*x1005))+new_r01);
evalcond[6]=((((-1.0)*x1007))+((new_r10*x1005))+((new_r00*x1006)));
evalcond[7]=(((cj2*x1016))+(((-1.0)*x1006*x1007))+new_r00);
evalcond[8]=((((-1.0)*cj2*x1006*x1007))+x1016+new_r11);
evalcond[9]=((((-1.0)*x1009*x1017))+(((-1.0)*x1005*x1007))+new_r10);
evalcond[10]=(x1011+(((-1.0)*sj3*x1009))+(((-1.0)*new_r00*x1010)));
evalcond[11]=(x1015+(((-1.0)*cj2*x1007))+(((-1.0)*new_r01*x1010)));
evalcond[12]=((((-1.0)*new_r02*x1005*x1009))+((cj2*x1013))+((new_r22*sj2)));
evalcond[13]=((((-1.0)*x1008*x1011))+((new_r00*x1014))+((cj2*new_r20)));
evalcond[14]=((((-1.0)*x1008*x1015))+((cj2*new_r21))+((new_r01*x1014)));
evalcond[15]=((-1.0)+((new_r02*x1014))+(((-1.0)*x1008*x1013))+((cj2*new_r22)));
evalcond[16]=((((-1.0)*sj3))+((new_r20*sj2))+((cj2*x1011))+(((-1.0)*new_r00*x1005*x1009)));
evalcond[17]=((((-1.0)*new_r01*x1005*x1009))+(((-1.0)*x1007))+((cj2*x1015))+((new_r21*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "0c565a9a7122c1ad3810c7b101fdfd65"; }

IKFAST_API const char* GetIkFastVersion() { return "0x1000004a"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
